{"ColorTeam.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\n\ncontract ColorTeam is Modifiers {\n\n    using SafeMath for uint;\n\n    //100 last painters for winning color =color team\n    function formColorTeam(uint _winnerColor) private returns (uint) {\n        uint paintsCurrentRoundForColor = paintsCounterForColor[_winnerColor];\n         if (paintsCurrentRoundForColor\u003e1000)\n        {\n            paintsCurrentRoundForColor = 1000;\n        }\n        for (uint i =paintsCurrentRoundForColor; i \u003e 0; i--) {\n            uint teamMembersCounter;\n            if (isInCBT[cbIteration][counterToPainterForColor[_winnerColor][i]] == false) {\n                \n                if (paintsCurrentRoundForColor \u003e 100) {\n                    if (teamMembersCounter \u003e= 100)   \n                        break;\n                }\n            \n                else {\n                    if (teamMembersCounter \u003e= paintsCurrentRoundForColor)\n                        break;\n                }\n                \n                cbTeam[cbIteration].push(counterToPainterForColor[_winnerColor][i]);\n                teamMembersCounter = teamMembersCounter.add(1);\n                isInCBT[cbIteration][counterToPainterForColor[_winnerColor][i]] = true;\n            }\n        }\n        return cbTeam[cbIteration].length;\n    }\n    \n    function calculateCBP(uint _winnerColor) private {\n\n        uint length = formColorTeam(_winnerColor);\n        address painter;\n        uint totalPaintsForTeam; \n\n        for (uint i = 0; i \u003c length; i++) {\n            painter = cbTeam[cbIteration][i];\n            totalPaintsForTeam += colorBankShare[cbIteration][_winnerColor][painter];\n        }\n        \n        for (i = 0; i \u003c length; i++) {\n            painter = cbTeam[cbIteration][i];\n            painterToCBP[cbIteration][painter] = (colorBankShare[cbIteration][_winnerColor][painter].mul(colorBankForRound[currentRound])).div(totalPaintsForTeam);\n        }\n\n    }\n\n    function distributeCBP() external canDistributeCBP() {\n        require(isCBPTransfered[cbIteration] == false, \"Color Bank Prizes already transferred for this cbIteration\");\n        address painter;\n        calculateCBP(winnerColorForRound[currentRound]);\n        painterToCBP[cbIteration][winnerOfRound[currentRound]] += colorBankForRound[currentRound];\n        uint length = cbTeam[cbIteration].length;\n        for (uint i = 0; i \u003c length; i++) {\n            painter = cbTeam[cbIteration][i];\n            if (painterToCBP[cbIteration][painter] != 0) {\n                uint prize = painterToCBP[cbIteration][painter];\n                painter.transfer(prize);\n                emit CBPDistributed(currentRound, cbIteration, painter, prize);\n            }\n        }\n        isCBPDistributable = false;\n        isCBPTransfered[cbIteration] = true;\n        currentRound = currentRound.add(1); \n        cbIteration = cbIteration.add(1); \n        isGamePaused = false;\n    }\n    \n}"},"DividendsDistributor.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./IColor.sol\";\nimport \"./Modifiers.sol\";\n\ncontract DividendsDistributor is Modifiers {\n    using SafeMath for uint;\n    \n    function claimDividends() external {\n        //if users dividends=0, revert \n        require(pendingWithdrawals[msg.sender] != 0, \"Your withdrawal balance is zero.\");\n        claimId = claimId.add(1);\n        Claim memory c;\n        c.id = claimId;\n        c.claimer = msg.sender;\n        c.isResolved = false;\n        c.timestamp = now;\n        claims.push(c);\n        emit DividendsClaimed(msg.sender, claimId, now);\n    }\n    \n     function withdrawFoundersComission() external onlyAdmin() returns (bool) {\n        require(pendingWithdrawals[founders] != 0, \"Foundrs withdrawal balance is zero.\");\n        uint balance = pendingWithdrawals[founders];\n        pendingWithdrawals[founders] = 0;\n        founders.transfer(balance);\n        return true;\n    }\n    \n\n    function approveClaim(uint _claimId) public onlyAdmin() {\n        \n        Claim storage claim = claims[_claimId];\n        \n        require(!claim.isResolved);\n        \n        address claimer = claim.claimer;\n\n        //Checks-Effects-Interactions pattern\n        uint withdrawalAmount = pendingWithdrawals[claimer];\n\n        \n        pendingWithdrawals[claimer] = 0;\n\n        \n        claimer.transfer(withdrawalAmount);\n        \n        //set last withdr time for user\n        addressToLastWithdrawalTime[claimer] = now;\n        emit DividendsWithdrawn(claimer, _claimId, withdrawalAmount);\n\n        claim.isResolved = true;\n    }\n\n}"},"ERC1538Delegate.sol":{"content":"pragma solidity 0.4.24;\nimport \"./IERC1538.sol\";\nimport \"./ERC1538QueryDelegates.sol\";\n\n/******************************************************************************\\\n* Implementation of ERC1538.\n* Function signatures are stored in an array so functions can be queried.\n/******************************************************************************/\n\ncontract ERC1538Delegate is IERC1538, ERC1538QueryDelegates {\n\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external onlyOwner {\n        // pos is first used to check the size of the delegate contract.\n        // After that pos is the current memory location of _functionSignatures.\n        // It is used to move through the characters of _functionSignatures\n        uint256 pos;\n        if(_delegate != address(0)) {\n            assembly {\n                pos := extcodesize(_delegate)\n            }\n            require(pos \u003e 0, \"_delegate address is not a contract and is not address(0)\");\n        }\n        // creates a bytes vesion of _functionSignatures\n        bytes memory signatures = bytes(_functionSignatures);\n        // stores the position in memory where _functionSignatures ends.\n        uint256 signaturesEnd;\n        // stores the starting position of a function signature in _functionSignatures\n        uint256 start;\n        assembly {\n            pos := add(signatures,32)\n            start := pos\n            signaturesEnd := add(pos,mload(signatures))\n        }\n        // the function id of the current function signature\n        bytes4 funcId;\n        // the delegate address that is being replaced or address(0) if removing functions\n        address oldDelegate;\n        // the length of the current function signature in _functionSignatures\n        uint256 num;\n        // the current character in _functionSignatures\n        uint256 char;\n        // the position of the current function signature in the funcSignatures array\n        uint256 index;\n        // the last position in the funcSignatures array\n        uint256 lastIndex;\n        // parse the _functionSignatures string and handle each function\n        for (; pos \u003c signaturesEnd; pos++) {\n            assembly {char := byte(0,mload(pos))}\n            // 0x29 == )\n            if (char == 0x29) {\n                pos++;\n                num = (pos - start);\n                start = pos;\n                assembly {\n                    mstore(signatures,num)\n                }\n                funcId = bytes4(keccak256(signatures));\n                oldDelegate = delegates[funcId];\n                if(_delegate == address(0)) {\n                    index = funcSignatureToIndex[signatures];\n                    require(index != 0, \"Function does not exist.\");\n                    index--;\n                    lastIndex = funcSignatures.length - 1;\n                    if (index != lastIndex) {\n                        funcSignatures[index] = funcSignatures[lastIndex];\n                        funcSignatureToIndex[funcSignatures[lastIndex]] = index + 1;\n                    }\n                    funcSignatures.length--;\n                    delete funcSignatureToIndex[signatures];\n                    delete delegates[funcId];\n                    emit FunctionUpdate(funcId, oldDelegate, address(0), string(signatures));\n                }\n                else if (funcSignatureToIndex[signatures] == 0) {\n                    require(oldDelegate == address(0), \"Funcion id clash.\");\n                    delegates[funcId] = _delegate;\n                    funcSignatures.push(signatures);\n                    funcSignatureToIndex[signatures] = funcSignatures.length;\n                    emit FunctionUpdate(funcId, address(0), _delegate, string(signatures));\n                }\n                else if (delegates[funcId] != _delegate) {\n                    delegates[funcId] = _delegate;\n                    emit FunctionUpdate(funcId, oldDelegate, _delegate, string(signatures));\n\n                }\n                assembly {signatures := add(signatures,num)}\n            }\n        }\n        emit CommitMessage(commitMessage);\n    }\n}"},"ERC1538QueryDelegates.sol":{"content":"pragma solidity 0.4.24;\n/******************************************************************************\\\n* \n* Contains functions for retrieving function signatures and delegate contract\n* addresses.\n/******************************************************************************/\n\nimport \"./StorageV0.sol\";\nimport \"./IERC1538Query.sol\";\n\ncontract ERC1538QueryDelegates is IERC1538Query, StorageV0 {\n\n    function totalFunctions() external view returns(uint256) {\n        return funcSignatures.length;\n    }\n\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate) {\n        require(_index \u003c funcSignatures.length, \"functionSignatures index does not exist.\");\n        bytes memory signature = funcSignatures[_index];\n        functionId = bytes4(keccak256(signature));\n        delegate = delegates[functionId];\n        return (string(signature), functionId, delegate);\n    }\n\n    function functionExists(string _functionSignature) external view returns(bool) {\n        return funcSignatureToIndex[bytes(_functionSignature)] != 0;\n    }\n\n    function functionSignatures() external view returns(string) {\n        uint256 signaturesLength;\n        bytes memory signatures;\n        bytes memory signature;\n        uint256 functionIndex;\n        uint256 charPos;\n        uint256 funcSignaturesNum = funcSignatures.length;\n        bytes[] memory memoryFuncSignatures = new bytes[](funcSignaturesNum);\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = funcSignatures[functionIndex];\n            signaturesLength += signature.length;\n            memoryFuncSignatures[functionIndex] = signature;\n        }\n        signatures = new bytes(signaturesLength);\n        functionIndex = 0;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = memoryFuncSignatures[functionIndex];\n            for(uint256 i = 0; i \u003c signature.length; i++) {\n                signatures[charPos] = signature[i];\n                charPos++;\n            }\n        }\n        return string(signatures);\n    }\n\n    function delegateFunctionSignatures(address _delegate) external view returns(string) {\n        uint256 funcSignaturesNum = funcSignatures.length;\n        bytes[] memory delegateSignatures = new bytes[](funcSignaturesNum);\n        uint256 delegateSignaturesPos;\n        uint256 signaturesLength;\n        bytes memory signatures;\n        bytes memory signature;\n        uint256 functionIndex;\n        uint256 charPos;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            signature = funcSignatures[functionIndex];\n            if(_delegate == delegates[bytes4(keccak256(signature))]) {\n                signaturesLength += signature.length;\n                delegateSignatures[delegateSignaturesPos] = signature;\n                delegateSignaturesPos++;\n            }\n\n        }\n        signatures = new bytes(signaturesLength);\n        functionIndex = 0;\n        for(; functionIndex \u003c delegateSignatures.length; functionIndex++) {\n            signature = delegateSignatures[functionIndex];\n            if(signature.length == 0) {\n                break;\n            }\n            for(uint256 i = 0; i \u003c signature.length; i++) {\n                signatures[charPos] = signature[i];\n                charPos++;\n            }\n        }\n        return string(signatures);\n    }\n\n    function delegateAddress(string _functionSignature) external view returns(address) {\n        require(funcSignatureToIndex[bytes(_functionSignature)] != 0, \"Function signature not found.\");\n        return delegates[bytes4(keccak256(bytes(_functionSignature)))];\n    }\n\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate) {\n        for(uint256 i = 0; i \u003c funcSignatures.length; i++) {\n            if(_functionId == bytes4(keccak256(funcSignatures[i]))) {\n                return (string(funcSignatures[i]), delegates[_functionId]);\n            }\n        }\n        revert(\"functionId not found\");\n    }\n\n    function delegateAddresses() external view returns(address[]) {\n        uint256 funcSignaturesNum = funcSignatures.length;\n        address[] memory delegatesBucket = new address[](funcSignaturesNum);\n        uint256 numDelegates;\n        uint256 functionIndex;\n        bool foundDelegate;\n        address delegate;\n        for(; functionIndex \u003c funcSignaturesNum; functionIndex++) {\n            delegate = delegates[bytes4(keccak256(funcSignatures[functionIndex]))];\n            for(uint256 i = 0; i \u003c numDelegates; i++) {\n                if(delegate == delegatesBucket[i]) {\n                    foundDelegate = true;\n                    break;\n                }\n            }\n            if(foundDelegate == false) {\n                delegatesBucket[numDelegates] = delegate;\n                numDelegates++;\n            }\n            else {\n                foundDelegate = false;\n            }\n        }\n        address[] memory delegates_ = new address[](numDelegates);\n        functionIndex = 0;\n        for(; functionIndex \u003c numDelegates; functionIndex++) {\n            delegates_[functionIndex] = delegatesBucket[functionIndex];\n        }\n        return delegates_;\n    }\n}"},"Game.sol":{"content":"pragma solidity 0.4.24;\nimport \"./PaintsPool.sol\";\nimport \"./PaintDiscount.sol\";\nimport \"./Modifiers.sol\";\nimport \"./Utils.sol\";\n\ncontract Game is PaintDiscount, PaintsPool, Modifiers {\n    using SafeMath for uint;\n\n     //function estimating call price for given color\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {\n\n        uint moneySpent = moneySpentByUserForColor[_color][msg.sender];\n        bool hasDiscount = hasPaintDiscountForColor[_color][msg.sender];\n        uint discount = usersPaintDiscountForColor[_color][msg.sender];\n        \n        for (uint i = 0; i \u003c _pixels.length; i++) {\n            \n            uint discountCallPrice = (nextCallPriceForColor[_color].mul(100 - discount)).div(100);\n            \n            if (hasDiscount == true) \n                uint price = discountCallPrice;\n            else\n                price = nextCallPriceForColor[_color]; \n\n            totalCallPrice += price;\n            moneySpent += price;\n\n            if (moneySpent \u003e= 1 ether) {\n                \n                hasDiscount = true;\n                discount = moneySpent / 1 ether;\n                \n                if (moneySpent \u003e= 10 ether)\n                    discount = 10;\n            }\n            \n        }   \n    }\n\n    function drawTimeBank() public {\n\n        uint lastPaintTime = lastPaintTimeForRound[currentRound];\n        require ((now - lastPaintTime) \u003e 20 minutes \u0026\u0026 lastPaintTime != 0, \"20 minutes have not passed yet.\");\n\n        \n        winnerOfRound[currentRound] = lastPainterForRound[currentRound];\n\n        //timebank(1) was drawn for this round\n        winnerBankForRound[currentRound] = 1; \n        //10% of time bank goes to next round\n        timeBankForRound[currentRound + 1] = timeBankForRound[currentRound].div(10); \n        //45% of time bank goes to every participant in a round\n        timeBankForRound[currentRound] = timeBankForRound[currentRound].mul(45).div(100); \n        //color bank goes to next round\n        colorBankForRound[currentRound + 1] = colorBankForRound[currentRound]; \n        \n        colorBankForRound[currentRound] = 0; \n       \n        emit TimeBankPlayed(winnerOfRound[currentRound], currentRound);\n\n        isTBPDistributable = true;\n        isGamePaused = true;\n        timeBankDrawnForRound[currentRound] = true;\n\n    }\n\n    \n    function paint(uint[] _pixels, uint _color, string _refLink) external payable isRegistered(_refLink) isLiveGame() {\n\n        require(msg.value == estimateCallPrice(_pixels, _color), \"Wrong call price\");\n        require(_color \u003e 0 \u0026\u0026 _color \u003c= totalColorsNumber, \"The color with such id does not exist.\"); \n\n        // bytes32 refLink32 = Utils.toBytes32(_refLink);\n        // require(keccak256(abi.encodePacked(_refLink)) == keccak256(abi.encodePacked()) || refLinkExists[refLink32] == true, \"No such referral link exists.\");\n        \n       //check whether 20 minutes passed since last paint \n        if ((now - lastPaintTimeForRound[currentRound]) \u003e 20 minutes \u0026\u0026 \n            lastPaintTimeForRound[currentRound] != 0 \u0026\u0026 \n            timeBankDrawnForRound[currentRound] == false) {\n\n            drawTimeBank();\n            msg.sender.transfer(msg.value);\n\n        }\n        \n        else {\n            //distribute money to banks and dividends\n            _setBanks(_color);\n\n            //paint pixels\n            for (uint i = 0; i \u003c _pixels.length; i++) {\n                _paint(_pixels[i], _color);\n            }\n            \n            \n            _distributeDividends(_color, _refLink);\n        \n            //save user spended money for this color\n            _setMoneySpentByUserForColor(_color); \n            \n           \n            _setUsersPaintDiscountForColor(_color);\n\n            if (paintsCounterForColor[_color] == 0) {\n                paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] = now;\n            }\n\n            paintsCounter++; //counter for all users paints\n            paintsCounterForColor[_color] ++; //counter for given color\n            counterToPainter[paintsCounter] = msg.sender; //counter for given user\n            counterToPainterForColor[_color][paintsCounterForColor[_color]] = msg.sender; \n\n            if (isUserCountedForRound[currentRound][msg.sender] == false) {\n                usersCounterForRound[currentRound] = usersCounterForRound[currentRound].add(1);\n                isUserCountedForRound[currentRound][msg.sender] = true;\n            }\n        }\n\n    }   \n\n    \n    function _paint(uint _pixel, uint _color) internal {\n\n        //set paints amount in a pool and price for paint\n        _fillPaintsPool(_color);\n        \n        require(msg.sender == tx.origin);\n\n        require(_pixel \u003e 0 \u0026\u0026 _pixel \u003c= totalPixelsNumber, \"The pixel with such id does not exist.\");\n\n       \n     \n        uint oldColor = pixelToColorForRound[currentRound][_pixel];\n    \n        \n        pixelToColorForRound[currentRound][_pixel] = _color; \n            \n        //save old color for pixel\n        pixelToOldColorForRound[currentRound][_pixel] = oldColor; \n                \n      \n        lastPaintTimeForRound[currentRound] = now; \n    \n       \n        lastPainterForRound[currentRound] = msg.sender;\n                \n       \n        if (colorToPaintedPixelsAmountForRound[currentRound][oldColor] \u003e 0) \n            colorToPaintedPixelsAmountForRound[currentRound][oldColor] = colorToPaintedPixelsAmountForRound[currentRound][oldColor].sub(1); \n    \n        \n        colorToPaintedPixelsAmountForRound[currentRound][_color] = colorToPaintedPixelsAmountForRound[currentRound][_color].add(1); \n\n        //increase paints amount for given color for color team iteration\n        colorToTotalPaintsForCBIteration[cbIteration][_color] = colorToTotalPaintsForCBIteration[cbIteration][_color].add(1);\n\n        \n        totalPaintsForRound[currentRound] = totalPaintsForRound[currentRound].add(1); \n\n        pixelToPaintTimeForRound[currentRound][_pixel] = now;\n\n       \n        if (lastPaintTimeOfUser[msg.sender] != 0 \u0026\u0026 now - lastPaintTimeOfUser[msg.sender] \u003c 24 hours) \n            timeBankShare[tbIteration][msg.sender]++;\n            \n        else    \n            timeBankShare[tbIteration][msg.sender] = 1;\n\n        \n        if (lastPaintTimeOfUserForColor[_color][msg.sender] != 0 \u0026\u0026 now - lastPaintTimeOfUserForColor[_color][msg.sender] \u003c 24 hours) \n            colorBankShare[cbIteration][_color][msg.sender]++;\n\n        else \n            colorBankShare[cbIteration][_color][msg.sender] = 1;\n\n        lastPaintTimeOfUser[msg.sender] = now;\n        lastPaintTimeOfUserForColor[_color][msg.sender] = now;\n                \n        //decrease paints pool by 1 \n        paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]].sub(1);\n        \n       \n        lastPaintedPixelForRound[currentRound] = _pixel;\n        \n        \n        emit Paint(_pixel, _color, msg.sender, currentRound, now);    \n\n        \n        lastPlayedRound[msg.sender] = currentRound;\n            \n        //chreck wherether all pixels are the same color\n        if (colorToPaintedPixelsAmountForRound[currentRound][_color] == totalPixelsNumber) {\n\n           \n            winnerColorForRound[currentRound] = _color;\n\n            \n            winnerOfRound[currentRound] = lastPainterForRound[currentRound];        \n            //color bank(2)\n            winnerBankForRound[currentRound] = 2;\n            //10% goes to next round  \n            colorBankForRound[currentRound + 1] = colorBankForRound[currentRound].div(10); \n            //45% for color team \n            colorBankForRound[currentRound] = colorBankForRound[currentRound].mul(45).div(100);\n            //timebank goes to next round\n            timeBankForRound[currentRound + 1] = timeBankForRound[currentRound];\n            timeBankForRound[currentRound] = 0;     \n            emit ColorBankPlayed(winnerOfRound[currentRound], currentRound);  \n            \n            isGamePaused = true;\n            isCBPDistributable = true;\n            //distributeCBP();\n        }\n    }\n\n    \n    function _setBanks(uint _color) private {\n        \n        colorBankToColorForRound[currentRound][_color] = colorBankToColorForRound[currentRound][_color].add(msg.value.mul(40).div(100));\n\n        //40% to color colorBank\n        colorBankForRound[currentRound] = colorBankForRound[currentRound].add(msg.value.mul(40).div(100));\n\n        //40% to timebank\n        timeBankForRound[currentRound] = timeBankForRound[currentRound].add(msg.value.mul(40).div(100));\n\n        //20% goes to dividends \n        dividendsBank = dividendsBank.add(msg.value.div(5)); \n    }\n\n    \n    function _distributeDividends(uint _color, string _refLink) internal {\n        \n        //require(ownerOfColor[_color] != address(0), \"There is no such color\");\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\n    \n        //if  reflink provided\n        if (refLinkExists[refLink32] == true) { \n\n            //25% goes to founders\n            pendingWithdrawals[founders] = pendingWithdrawals[founders].add(dividendsBank.div(4)); \n\n            //25% owner of color\n            pendingWithdrawals[ownerOfColor[_color]] += dividendsBank.div(4);\n            //25% owner of pixel\n            pendingWithdrawals[ownerOfPixel] += dividendsBank.div(4);\n\n            //25% to referal\n            pendingWithdrawals[refLinkToUser[refLink32]] += dividendsBank.div(4);\n            dividendsBank = 0;\n        }\n\n        else {\n\n            pendingWithdrawals[founders] = pendingWithdrawals[founders].add(dividendsBank.div(3)); \n            pendingWithdrawals[ownerOfColor[_color]] += dividendsBank.div(3);\n            pendingWithdrawals[ownerOfPixel] += dividendsBank.div(3);\n            dividendsBank = 0;\n        }\n    }\n\n    modifier isRegistered(string _refLink) {\n      \n        if (isRegisteredUser[msg.sender] != true) {\n            bytes32 refLink32 = Utils.toBytes16(_refLink);\n             \n            if (refLinkExists[refLink32]) { \n                address referrer = refLinkToUser[refLink32];\n                referrerToReferrals[referrer].push(msg.sender);\n                referralToReferrer[msg.sender] = referrer;\n                hasReferrer[msg.sender] = true;\n            }\n            uniqueUsersCount = uniqueUsersCount.add(1);\n            newUserToCounter[msg.sender] = uniqueUsersCount;\n            registrationTimeForUser[msg.sender] = now;\n            isRegisteredUser[msg.sender] = true;\n        }\n        _;\n    }\n\n}"},"GameStateController.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Roles.sol\";\nimport \"./Modifiers.sol\";\n\ncontract GameStateController is Modifiers {\n\n    function pauseGame() external onlyAdmin() {\n        require (isGamePaused == false, \"Game is already paused\");\n        isGamePaused = true;\n    }\n\n    function resumeGame() external onlyAdmin() {\n        require (isGamePaused == true, \"Game is already live\");\n        isGamePaused = false;\n    }\n\n    function withdrawEther() external onlyAdmin() returns (bool) {\n        require (isGamePaused == true, \"Can withdraw when game is live\");\n        uint balance = address(this).balance;\n        uint colorBank = colorBankForRound[currentRound];\n        uint timeBank = timeBankForRound[currentRound];\n        owner().transfer(balance);\n        colorBankForRound[currentRound]= 0;\n        timeBankForRound[currentRound]= 0;\n        emit EtherWithdrawn(balance, colorBank, timeBank, now);\n        return true;\n    }\n    \n}\n"},"Helpers.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\ncontract Helpers is Modifiers {\n\n   \n    function getPixelColor(uint _pixel) external view returns (uint) {\n        return pixelToColorForRound[currentRound][_pixel];\n    }\n\n    //function adding new color to the game after minting\n    function addNewColor() external onlyAdmin() {\n        totalColorsNumber++; //TODO - Check whether this line should be put in the end or here\n        currentPaintGenForColor[totalColorsNumber] = 1;\n        callPriceForColor[totalColorsNumber] = 0.01 ether;\n        nextCallPriceForColor[totalColorsNumber] = callPriceForColor[totalColorsNumber];\n        paintGenToAmountForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = maxPaintsInPool;\n        paintGenStartedForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = true;\n        paintGenToEndTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber] - 1] = now;\n        paintGenToStartTimeForColor[totalColorsNumber][currentPaintGenForColor[totalColorsNumber]] = now;\n    }\n\n}"},"IColor.sol":{"content":"pragma solidity 0.4.24;\n\ninterface Color {\n    function totalSupply() external view returns (uint);\n    function ownerOf(uint _tokenId) external view returns (address);\n}\n\n"},"IERC1538.sol":{"content":"pragma solidity 0.4.24;\n\ninterface IERC1538 {\n    event CommitMessage(string message);\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external;\n}"},"IERC1538Query.sol":{"content":"pragma solidity 0.4.24;\n\ninterface IERC1538Query {\n    function totalFunctions() external view returns(uint256);\n    function functionByIndex(uint256 _index) external view returns(string memory functionSignature, bytes4 functionId, address delegate);\n    function functionExists(string _functionSignature) external view returns(bool);\n    function functionSignatures() external view returns(string);\n    function delegateFunctionSignatures(address _delegate) external view returns(string);\n    function delegateAddress(string _functionSignature) external view returns(address);\n    function functionById(bytes4 _functionId) external view returns(string signature, address delegate);\n    function delegateAddresses() external view returns(address[]);\n}"},"Initializer.sol":{"content":"pragma solidity 0.4.24;\nimport \"./StorageV1.sol\";\n\ncontract Initializer is StorageV1 {\n\n    //constructor\n    function _initializer() internal {\n\n        \n        refLinkPrice  = 0.1 ether;\n        totalColorsNumber = 8;\n        totalPixelsNumber = 49;\n        \n        isAdmin[msg.sender] = true;\n        maxPaintsInPool = totalPixelsNumber; \n        currentRound = 1;\n        cbIteration = 1;\n        tbIteration = 1;\n        \n        for (uint i = 1; i \u003c= totalColorsNumber; i++) {\n            currentPaintGenForColor[i] = 1;\n            callPriceForColor[i] = 0.005 ether;\n            nextCallPriceForColor[i] = callPriceForColor[i];\n            paintGenToAmountForColor[i][currentPaintGenForColor[i]] = maxPaintsInPool;\n            paintGenStartedForColor[i][currentPaintGenForColor[i]] = true;\n            //paintGenToEndTimeForColor[i][currentPaintGenForColor[i] - 1] = now;\n            paintGenToStartTimeForColor[i][currentPaintGenForColor[i]] = now;\n        }\n        \n    }\n}\n"},"IPixel.sol":{"content":"pragma solidity 0.4.24;\n\ninterface Pixel {\n    function totalSupply() external view returns (uint);\n    function ownerOf(uint _tokenId) external view returns (address);\n}\n\n"},"Migrations.sol":{"content":"pragma solidity ^0.4.23;\n\ncontract Migrations {\n  address public owner;\n  uint public last_completed_migration;\n\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  modifier restricted() {\n    if (msg.sender == owner) _;\n  }\n\n  function setCompleted(uint completed) public restricted {\n    last_completed_migration = completed;\n  }\n\n  function upgrade(address new_address) public restricted {\n    Migrations upgraded = Migrations(new_address);\n    upgraded.setCompleted(last_completed_migration);\n  }\n}\n"},"Modifiers.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract Modifiers is StorageV1 {\n    using SafeMath for uint;\n\n    modifier onlyAdmin() {\n        require(isAdmin[msg.sender] == true, \"You don\u0027t have admin rights.\");\n        _;\n    }\n\n    modifier isLiveGame() {\n        require(isGamePaused == false, \"Game is paused.\");\n        _;\n    }\n\n    modifier canDistributeCBP() {\n        require(isCBPDistributable == true, \"Cannot distribute color bank prize at the moment.\");\n        _;\n    }\n\n    modifier canDistributeTBP() {\n        require(isTBPDistributable == true, \"Cannot distribute time bank prize at the moment.\");\n        _;\n    }\n\n    //should be 4-8 symbols\n    modifier isValidRefLink(string _str) {\n        require(bytes(_str).length \u003e= 4, \"Ref link should be of length [4,8]\");\n        require(bytes(_str).length \u003c= 8, \"Ref link should be of length [4,8]\");\n        _;\n    }\n    \n}"},"Ownable.sol":{"content":"pragma solidity 0.4.24;\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address private _owner;\n\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() internal {\n    _owner = msg.sender;\n    emit OwnershipTransferred(address(0), _owner);\n  }\n\n  /**\n   * @return the address of the owner.\n   */\n  function owner() public view returns(address) {\n    return _owner;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(isOwner());\n    _;\n  }\n\n  /**\n   * @return true if `msg.sender` is the owner of the contract.\n   */\n  function isOwner() public view returns(bool) {\n    return msg.sender == _owner;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipTransferred(_owner, address(0));\n    _owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) public onlyOwner {\n    _transferOwnership(newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address newOwner) internal {\n    require(newOwner != address(0));\n    emit OwnershipTransferred(_owner, newOwner);\n    _owner = newOwner;\n  }\n}\n"},"PaintDiscount.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract PaintDiscount is StorageV1 {\n    using SafeMath for uint;\n    \n    //saving discount for user\n    function _setUsersPaintDiscountForColor(uint _color) internal {\n        \n        //each 1 eth = 1% discount\n        usersPaintDiscountForColor[_color][msg.sender] = moneySpentByUserForColor[_color][msg.sender] / 1 ether;\n        \n        //max discount 10% \n        if (moneySpentByUserForColor[_color][msg.sender] \u003e= 10 ether)\n            usersPaintDiscountForColor[_color][msg.sender] = 10;\n        \n    }\n    \n    //Money spent by user buying this color  \n    function _setMoneySpentByUserForColor(uint _color) internal {\n        \n        moneySpentByUserForColor[_color][msg.sender] += msg.value;\n        moneySpentByUser[msg.sender] += msg.value;\n\n        if (moneySpentByUserForColor[_color][msg.sender] \u003e= 1 ether)\n            hasPaintDiscountForColor[_color][msg.sender] = true;\n    }\n}"},"PaintsPool.sol":{"content":"pragma solidity ^0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./StorageV1.sol\";\n\ncontract PaintsPool is StorageV1 {\n    using SafeMath for uint;\n\n    //update paint price\n    function _updateCallPrice(uint _color) private {\n        \n        //increase call price for 5%(for frontend)\n        nextCallPriceForColor[_color] = callPriceForColor[_color].mul(105).div(100);\n        \n        \n        emit CallPriceUpdated(callPriceForColor[_color]);\n    }\n     \n    \n    \n    function _fillPaintsPool(uint _color) internal {\n\n        \n        uint nextPaintGen = currentPaintGenForColor[_color].add(1);\n        //each 5 min we produce new paint generation\n        if (now - paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color] - 1] \u003e= 5 minutes) { \n            \n            \n            uint paintsRemain = paintGenToAmountForColor[_color][currentPaintGenForColor[_color]]; \n            \n            //if 5 min passed and new gen not yet started     \n            if (paintGenStartedForColor[_color][nextPaintGen] == false) {\n                \n                //we create new gen with amount of paints remaining \n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool.sub(paintsRemain); \n                \n                \n                paintGenToStartTimeForColor[_color][nextPaintGen] = now; \n\n                paintGenStartedForColor[_color][nextPaintGen] = true;\n            }\n            \n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 1) {\n                \n                \n                _updateCallPrice(_color);\n                \n                //current gen paiints ends now \n                paintGenToEndTimeForColor[_color][currentPaintGenForColor[_color]] = now;\n            }\n               \n            \n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\n                \n               \n                callPriceForColor[_color] = nextCallPriceForColor[_color];\n\n                if (paintGenToAmountForColor[_color][nextPaintGen] == 0) {\n                    paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\n                }\n                //now we use next gen paints\n                currentPaintGenForColor[_color] = nextPaintGen;\n            }\n        }\n        ///if 5 min not yet passed\n        else {\n\n            if (paintGenToAmountForColor[_color][currentPaintGenForColor[_color]] == 0) {\n               \n                paintGenToAmountForColor[_color][nextPaintGen] = maxPaintsInPool;\n                //we use next paint gen\n                currentPaintGenForColor[_color] = nextPaintGen;\n            }\n\n        }\n    }\n}"},"Referral.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\nimport \"./Utils.sol\";\n\ncontract Referral is Modifiers {\n    using SafeMath for uint;\n    \n    //ref link lenght 4-8 symbols \n    function buyRefLink(string _refLink) isValidRefLink (_refLink) external payable {\n        require(msg.value == refLinkPrice, \"Setting referral link costs 0.1 ETH.\");\n        require(hasRefLink[msg.sender] == false, \"You have already generated your ref link.\");\n        bytes32 refLink32 = Utils.toBytes16(_refLink);\n        require(refLinkExists[refLink32] != true, \"This referral link already exists, try different one.\");\n        hasRefLink[msg.sender] = true;\n        userToRefLink[msg.sender] = _refLink;\n        refLinkExists[refLink32] = true;\n        refLinkToUser[refLink32] = msg.sender;\n        owner().transfer(msg.value);\n    }\n\n   \n    function getReferralsForUser(address _user) external view returns (address[]) {\n        return referrerToReferrals[_user];\n    }\n\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {\n        registrationTime = registrationTimeForUser[_user];\n        moneySpent = moneySpentByUser[_user];\n    }\n    \n}"},"Roles.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\ncontract Roles is Modifiers {\n    \n    function addAdmin(address _new) external onlyOwner() {\n        isAdmin[_new] = true;\n    }\n    \n    function removeAdmin(address _admin) external onlyOwner() {\n        isAdmin[_admin] = false;\n    }\n\n    function renounceAdmin() external onlyAdmin() {\n        isAdmin[msg.sender] = false;\n    }\n\n}"},"Router.sol":{"content":"pragma solidity 0.4.24;\npragma experimental \"v0.5.0\";\nimport \"./Initializer.sol\";\n\ncontract Router is Initializer {\n    \n    event CommitMessage(string message);\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\n\n    constructor(address _erc1538Delegate) public  {\n\n        //Adding ERC1538 updateContract function\n        bytes memory signature = \"updateContract(address,string,string)\";\n        bytes4 funcId = bytes4(keccak256(signature));\n        delegates[funcId] = _erc1538Delegate;\n        funcSignatures.push(signature);\n        funcSignatureToIndex[signature] = funcSignatures.length;\n        emit FunctionUpdate(funcId, address(0), _erc1538Delegate, string(signature));\n        emit CommitMessage(\"Added ERC1538 updateContract function at contract creation\");\n    \n        _initializer();\n    }\n\n    function() external payable {\n        address delegate = delegates[msg.sig];\n        require(delegate != address(0), \"Function does not exist.\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize)\n            let result := delegatecall(gas, delegate, ptr, calldatasize, 0, 0)\n            let size := returndatasize\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 {revert(ptr, size)}\n            default {return (ptr, size)}\n        }\n    }\n}"},"SafeMath.sol":{"content":"pragma solidity 0.4.24;\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n\n    /**\n    * @dev Multiplies two numbers, reverts on overflow.\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b);\n\n        return c;\n    }\n\n    /**\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003e 0); // Solidity only automatically asserts when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    /**\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n    */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n    * @dev Adds two numbers, reverts on overflow.\n    */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a);\n\n        return c;\n    }\n\n    /**\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\n    * reverts when dividing by zero.\n    */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b != 0);\n        return a % b;\n    }\n}"},"StorageV0.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Ownable.sol\";\n\ncontract StorageV0 is Ownable {\n\n    // maps functions to the delegate contracts that execute the functions\n    // funcId =\u003e delegate contract\n    mapping(bytes4 =\u003e address) internal delegates;\n\n    // array of function signatures supported by the contract\n    bytes[] internal funcSignatures;\n\n    // maps each function signature to its position in the funcSignatures array.\n    // signature =\u003e index+1\n    mapping(bytes =\u003e uint256) internal funcSignatureToIndex;\n\n}"},"StorageV1.sol":{"content":"pragma solidity 0.4.24;\nimport \"./StorageV0.sol\";\nimport \"./IColor.sol\";\nimport \"./IPixel.sol\";\n\ncontract StorageV1 is StorageV0 {\n\n    //pixel color(round=\u003e pixel=\u003e color)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToColorForRound; \n\n    //old pixel color(round=\u003e pixel=\u003e color)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToOldColorForRound; \n\n    // (round =\u003e color =\u003e pixel amount)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorToPaintedPixelsAmountForRound; \n\n    //color bank for round (round =\u003e color bank)\n    mapping (uint =\u003e uint) public colorBankForRound; \n\n    //color bank for  color for round (round =\u003e color =\u003e color bank)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorBankToColorForRound; \n\n    //time bank for round (round =\u003e time bank)\n    mapping (uint =\u003e uint) public timeBankForRound; \n    \n    // (round =\u003e timestamp)\n    mapping (uint =\u003e uint) public lastPaintTimeForRound; \n\n    // (round =\u003e adress)\n    mapping (uint =\u003e address) public lastPainterForRound; \n\n    \n    mapping (uint =\u003e uint) public lastPaintedPixelForRound;\n\n    // (round =\u003e color) \n    mapping (uint =\u003e uint) public winnerColorForRound; \n\n    // (round =\u003e color =\u003e paints amount)\n    mapping (uint =\u003e mapping (uint =\u003e uint)) public colorToTotalPaintsForCBIteration; \n\n    // (round =\u003e adress)\n    mapping (uint =\u003e address) public winnerOfRound; \n\n    //bank drawn in round (round =\u003e drawn bank) (1 = time bank, 2 = color bank)\n    mapping (uint =\u003e uint) public winnerBankForRound; \n\n    \n    mapping (uint =\u003e mapping (uint =\u003e uint)) public pixelToPaintTimeForRound;\n\n   \n    mapping (uint =\u003e uint) public totalPaintsForRound;\n        \n    \n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToAmountForColor;\n    \n    \n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToStartTimeForColor;\n    \n    \n    mapping (uint =\u003e mapping (uint =\u003e uint)) public paintGenToEndTimeForColor;\n    \n    //bool \n    mapping (uint =\u003e mapping (uint =\u003e bool)) public paintGenStartedForColor;\n\n   \n    mapping (uint =\u003e uint) public currentPaintGenForColor;\n    \n   \n    mapping (uint =\u003e uint) public callPriceForColor;\n    \n \n    mapping (uint =\u003e uint) public nextCallPriceForColor;\n    \n    \n    mapping (uint =\u003e mapping (address =\u003e uint)) public moneySpentByUserForColor;\n\n    \n    mapping (address =\u003e uint) public moneySpentByUser;\n    \n    \n    mapping (uint =\u003e mapping (address =\u003e bool)) public hasPaintDiscountForColor;\n    \n    //in percent \n    mapping (uint =\u003e mapping (address =\u003e uint)) public usersPaintDiscountForColor;\n\n     \n    mapping (address =\u003e bool) public isRegisteredUser;\n    \n    \n    mapping (address =\u003e bool) public hasRefLink;\n\n   \n    mapping (address =\u003e address) public referralToReferrer;\n\n    \n    mapping (address =\u003e address[]) public referrerToReferrals;\n    \n   \n    mapping (address =\u003e bool) public hasReferrer;\n    \n    \n    mapping (address =\u003e string) public userToRefLink;\n    \n\n    mapping (bytes32 =\u003e address) public refLinkToUser;\n    \n    \n    mapping (bytes32 =\u003e bool) public refLinkExists;\n    \n   \n    mapping (address =\u003e uint) public newUserToCounter;\n    \n   \n    uint public uniqueUsersCount;\n\n   \n    uint public maxPaintsInPool;\n\n  \n    uint public currentRound;\n\n    //time bank iteration\n    uint public tbIteration;\n\n   //color bank iteration\n    uint public cbIteration;\n\n    \n    uint public paintsCounter; \n\n    //Time Bank Iteration =\u003e Painter =\u003e Painter\u0027s Share in Time Team\n    mapping (uint =\u003e mapping (address =\u003e uint)) public timeBankShare;\n\n    //Color Bank Iteration =\u003e Color =\u003e Painter =\u003e Painter\u0027s Share in Time Team\n    mapping (uint =\u003e mapping (uint =\u003e mapping (address =\u003e uint))) public colorBankShare;\n\n   \n    mapping (uint =\u003e uint) public paintsCounterForColor; \n\n    //cbIteration =\u003e color team\n    mapping (uint =\u003e address[]) public cbTeam; \n\n    //tbIteration =\u003e color team \n    mapping (uint =\u003e address[]) public tbTeam;\n\n     //counter =\u003e user\n    mapping (uint =\u003e address) public counterToPainter;\n\n    //color =\u003e counter =\u003e user    \n    mapping (uint =\u003e mapping (uint =\u003e address)) public counterToPainterForColor; \n\n    //cbIteration =\u003e user !should not be public\n    mapping (uint =\u003e mapping (address =\u003e bool)) public isInCBT; \n\n    //tbIteration =\u003e user !should not be public\n    mapping (uint =\u003e mapping (address =\u003e bool)) public isInTBT; \n\n    //cbIteration =\u003e painter =\u003e color bank prize\n    mapping (uint =\u003e mapping (address =\u003e uint)) public painterToCBP; \n\n    //tbIteration =\u003e painter =\u003e time bank prize\n    mapping (uint =\u003e mapping (address =\u003e uint)) public painterToTBP; \n\n    //сbIteration =\u003e  bool\n    mapping (uint =\u003e bool) public isCBPTransfered;\n\n    //tbIteration =\u003e bool\n    mapping (uint =\u003e bool) public isTBPTransfered;\n\n    \n    mapping (address =\u003e uint) public lastPlayedRound;\n    \n    //Dividends Distribution\n    mapping (uint =\u003e address) public ownerOfColor;\n\n    mapping (address =\u003e uint) public pendingWithdrawals; \n    \n    // (adress =\u003e time)\n    mapping (address =\u003e uint) public addressToLastWithdrawalTime; \n    \n  \n    uint public dividendsBank;\n\n    struct Claim {\n        uint id;\n        address claimer;\n        bool isResolved;\n        uint timestamp;\n    }\n\n    uint public claimId;\n\n    Claim[] public claims;\n\n    \n    address public ownerOfPixel = 0xca35b7d915458ef540ade6068dfe2f44e8fa733c;\n    address public founders =0xe04f921cf3d6c882C0FAa79d0810a50B1101e2D4;\n\n    bool public isGamePaused;\n    \n    bool public isCBPDistributable;\n    bool public isTBPDistributable;\n    \n    mapping(address =\u003e bool) public isAdmin;\n\n    Color public colorInstance;\n    Pixel public pixelInstance;\n\n    uint public totalColorsNumber; // 8\n    uint public totalPixelsNumber; //225 in V1\n\n   \n    uint public refLinkPrice; \n\n   \n    mapping (address =\u003e uint) public registrationTimeForUser;\n\n    mapping (address =\u003e uint) public lastPaintTimeOfUser;\n    mapping (uint =\u003e mapping (address =\u003e uint)) public lastPaintTimeOfUserForColor;\n\n    mapping (uint =\u003e bool) public timeBankDrawnForRound;\n\n    \n    mapping (uint =\u003e uint) public usersCounterForRound;\n \n    mapping (uint =\u003e mapping (address =\u003e bool)) public isUserCountedForRound;\n\n   // Events\n\n    event CBPDistributed(uint indexed round, uint indexed cbIteration, address indexed winner, uint prize);\n    event DividendsWithdrawn(address indexed withdrawer, uint indexed claimId, uint indexed amount);\n    event DividendsClaimed(address indexed claimer, uint indexed claimId, uint indexed currentTime);\n    event Paint(uint indexed pixelId, uint colorId, address indexed painter, uint indexed round, uint timestamp);\n    event ColorBankPlayed(address winnerOfRound, uint indexed round);\n    event TimeBankPlayed(address winnerOfRound, uint indexed round);\n    event CallPriceUpdated(uint indexed newCallPrice);\n    event TBPDistributed(uint indexed round, uint indexed tbIteration, address indexed winner, uint prize);\n    event EtherWithdrawn(uint balance, uint colorBank, uint timeBank, uint timestamp);\n}"},"TimeTeam.sol":{"content":"pragma solidity 0.4.24;\nimport \"./SafeMath.sol\";\nimport \"./Modifiers.sol\";\n\ncontract TimeTeam is Modifiers {\n    using SafeMath for uint;\n\n    //last 100 painters form a time team\n    function formTimeTeam() private returns (uint) {\n    uint paintsCurrentRound = paintsCounter; \n  \t  if (paintsCurrentRound\u003e1000)\n        {\n            paintsCurrentRound = 1000;\n        }\n        \n        for (uint i = paintsCurrentRound; i \u003e 0; i--) {\n            uint teamMembersCounter;\n            if (isInTBT[tbIteration][counterToPainter[i]] == false) {\n                \n                  if (teamMembersCounter \u003e= paintsCurrentRound)\n                        break;\n              \n                else {\n                    if (teamMembersCounter \u003e= 50)   \n                        break;\n                }\n                \n                \n                tbTeam[tbIteration].push(counterToPainter[i]);\n                teamMembersCounter = teamMembersCounter.add(1);\n                isInTBT[tbIteration][counterToPainter[i]] = true;\n            }\n        }\n        return tbTeam[tbIteration].length;\n    }\n    \n    function calculateTBP() private {\n\n        uint length = formTimeTeam();\n        address painter;\n        uint totalPaintsForTeam; \n\n        for (uint i = 0; i \u003c length; i++) {\n            painter = tbTeam[tbIteration][i];\n            totalPaintsForTeam += timeBankShare[tbIteration][painter];\n        }\n\n        for (i = 0; i \u003c length; i++) {\n            painter = tbTeam[tbIteration][i];\n            painterToTBP[tbIteration][painter] = (timeBankShare[tbIteration][painter].mul(timeBankForRound[currentRound])).div(totalPaintsForTeam);\n        }\n\n    }\n    function resetPaintsPool() internal {\n        \n    \n    for (uint i = 1; i \u003c= totalColorsNumber; i++){\n      \n        callPriceForColor[i] = 0.005 ether;\n        nextCallPriceForColor[i] = callPriceForColor[i];\n        currentPaintGenForColor[i]= 1;\n        \n        paintGenToAmountForColor[i][currentPaintGenForColor[i]] = maxPaintsInPool;\n        paintGenStartedForColor[i][currentPaintGenForColor[i]] = true;\n        paintGenToStartTimeForColor[i][currentPaintGenForColor[i]] = now;\n    }\n    \n    }\n\n    function distributeTBP() external canDistributeTBP() {\n        require(isTBPTransfered[tbIteration] == false, \"Time Bank Prizes already transferred for this tbIteration\");\n        address painter;\n        calculateTBP();\n        painterToTBP[tbIteration][winnerOfRound[currentRound]] += timeBankForRound[currentRound];\n        uint length = tbTeam[tbIteration].length;\n        for (uint i = 0; i \u003c length; i++) {\n            painter = tbTeam[tbIteration][i];\n            if (painterToTBP[tbIteration][painter] != 0) {\n                uint prize = painterToTBP[tbIteration][painter];\n                painter.transfer(prize);\n                emit TBPDistributed(currentRound, tbIteration, painter, prize);\n            }\n        }\n        isTBPDistributable = false;\n        isTBPTransfered[tbIteration] = true;\n        resetPaintsPool();\n        currentRound = currentRound.add(1); \n        tbIteration = tbIteration.add(1); \n        isGamePaused = false;\n    }\n}"},"Utils.sol":{"content":"pragma solidity 0.4.24;\n\nlibrary Utils {\n    \n    // convert a string less than 32 characters long to bytes32\n    function toBytes16(string _string) pure internal returns (bytes16) {\n        // make sure that the string isn\u0027t too long for this function\n        // will work but will cut off the any characters past the 32nd character\n        bytes16 _stringBytes;\n        string memory str = _string;\n    \n        // simplest way to convert 32 character long string\n        assembly {\n          // load the memory pointer of string with an offset of 32\n          // 32 passes over non-core data parts of string such as length of text\n          _stringBytes := mload(add(str, 32))\n        }\n        return _stringBytes;\n    }\n\n    \n    \n}"},"Wrapper.sol":{"content":"pragma solidity 0.4.24;\nimport \"./Modifiers.sol\";\n\n/**\n** Wrapper for Router Contract to interact with all the functions\u0027 signatures\n**/\n\ncontract Wrapper is Modifiers {\n\n    //ColorTeam.sol\n    function distributeCBP() external {}\n\n    //TimeTeam.sol\n    function distributeTBP() external {}\n\n    //DividendsDistributor.sol\n    function claimDividends() external {}\n    function approveClaim(uint _claimId) public {}\n\n    //GameStateController.sol\n    function pauseGame() external {}\n    function resumeGame() external {}\n    function withdrawEther() external returns (bool) {}\n\n    //Referral.sol\n    function buyRefLink(string _refLink) external payable {}\n    function getReferralsForUser(address _user) external view returns (address[]) {}\n    function getReferralData(address _user) external view returns (uint registrationTime, uint moneySpent) {}\n\n    //Roles.sol\n    function addAdmin(address _new) external {}\n    function removeAdmin(address _admin) external {}\n    function renounceAdmin() external {}\n\n    //Game.sol\n    function estimateCallPrice(uint[] _pixels, uint _color) public view returns (uint totalCallPrice) {}\n    function paint(uint[] _pixels, uint _color, string _refLink) external payable {}\n    function drawTimeBank() public {}\n\n    //ERC1538.sol\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external {}\n\n    //GameMock.sol\n    function mock() external {}\n    function mock2() external {}\n    function mock3(uint _winnerColor) external {}\n    function mockMaxPaintsInPool() external {}\n\n    //Helpers.sol\n    function getPixelColor(uint _pixel) external view returns (uint) {}\n    function addNewColor() external {}\n\n}"}}