{"DelegateProxy.sol":{"content":"pragma solidity ^0.4.18;\n\ncontract DelegateProxy {\n  /**\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n  * @param _dst Destination address to perform the delegatecall\n  * @param _calldata Calldata for the delegatecall\n  */\n  function delegatedFwd(address _dst, bytes _calldata) internal {\n    require(isContract(_dst));\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n      let size := returndatasize\n\n      let ptr := mload(0x40)\n      returndatacopy(ptr, 0, size)\n\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n    // if the call returned error data, forward it\n      switch result case 0 {revert(ptr, size)}\n      default {return (ptr, size)}\n    }\n  }\n\n  function isContract(address _target) internal view returns (bool) {\n    uint256 size;\n    assembly {size := extcodesize(_target)}\n    return size \u003e 0;\n  }\n}"},"Forwarder.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./DelegateProxy.sol\";\n\ncontract Forwarder is DelegateProxy {\n  // After compiling contract, `beefbeef...` is replaced in the bytecode by the real target address\n  address public constant target = 0x1ed7fc52ac5a37aa3ff6d9b94c894724e2f992b1; // checksumed to silence warning\n\n  /*\n  * @dev Forwards all calls to target\n  */\n  function() payable {\n    delegatedFwd(target, msg.data);\n  }\n}"}}