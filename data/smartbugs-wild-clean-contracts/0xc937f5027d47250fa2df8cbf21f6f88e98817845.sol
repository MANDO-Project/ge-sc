{"xgr_deposits.sol":{"content":"/*\r\n    xgr_deposits.sol\r\n    2.0.3\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_token.sol\";\r\nimport \"./xgr_token_db.sol\";\r\nimport \"./xgr_owned.sol\";\r\nimport \"./xgr_safeMath.sol\";\r\n\r\ncontract Deposits is Owned, SafeMath {\r\n    /* Structures */\r\n    struct depositTypes_s {\r\n        uint256 blockDelay;\r\n        uint256 baseFunds;\r\n        uint256 interestRateOnEnd;\r\n        uint256 interestRateBeforeEnd;\r\n        uint256 interestFee;\r\n        bool closeable;\r\n        bool valid;\r\n    }\r\n    struct deposits_s {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 interestOnEnd;\r\n        uint256 interestBeforeEnd;\r\n        uint256 interestFee;\r\n        uint256 interestMultiplier;\r\n        bool    closeable;\r\n        bool    valid;\r\n    }\r\n    /* Variables */\r\n    mapping(uint256 =\u003e depositTypes_s) public depositTypes;\r\n    uint256 public depositTypesCounter;\r\n    address public tokenAddress;\r\n    address public databaseAddress;\r\n    address public founderAddress;\r\n    uint256 public interestMultiplier = 1e3;\r\n    /* Constructor */\r\n    function Deposits(address TokenAddress, address DatabaseAddress, address FounderAddress) {\r\n        tokenAddress = TokenAddress;\r\n        databaseAddress = DatabaseAddress;\r\n        founderAddress = FounderAddress;\r\n    }\r\n    /* Externals */\r\n    function changeDataBaseAddress(address newDatabaseAddress) external onlyForOwner {\r\n        databaseAddress = newDatabaseAddress;\r\n    }\r\n    function changeTokenAddress(address newTokenAddress) external onlyForOwner {\r\n        tokenAddress = newTokenAddress;\r\n    }\r\n    function changeFounderAddresss(address newFounderAddress) external onlyForOwner {\r\n        founderAddress = newFounderAddress;\r\n    }\r\n    function addDepositType(uint256 blockDelay, uint256 baseFunds, uint256 interestRateOnEnd,\r\n        uint256 interestRateBeforeEnd, uint256 interestFee, bool closeable) external onlyForOwner {\r\n        depositTypesCounter += 1;\r\n        uint256 DTID = depositTypesCounter;\r\n        depositTypes[DTID] = depositTypes_s(\r\n            blockDelay,\r\n            baseFunds,\r\n            interestRateOnEnd,\r\n            interestRateBeforeEnd,\r\n            interestFee,\r\n            closeable,\r\n            true\r\n        );\r\n        EventNewDepositType(\r\n            DTID,\r\n            blockDelay,\r\n            baseFunds,\r\n            interestRateOnEnd,\r\n            interestRateBeforeEnd,\r\n            interestFee,\r\n            interestMultiplier,\r\n            closeable\r\n        );\r\n    }\r\n    function rekoveDepositType(uint256 DTID) external onlyForOwner {\r\n        delete depositTypes[DTID].valid;\r\n        EventRevokeDepositType(DTID);\r\n    }\r\n    function placeDeposit(uint256 amount, uint256 depositType) external checkSelf {\r\n        require( depositTypes[depositType].valid );\r\n        require( depositTypes[depositType].baseFunds \u003c= amount );\r\n        uint256 balance = TokenDB(databaseAddress).balanceOf(msg.sender);\r\n        uint256 locked = TokenDB(databaseAddress).lockedBalances(msg.sender);\r\n        require( safeSub(balance, locked) \u003e= amount );\r\n        var (success, DID) = TokenDB(databaseAddress).openDeposit(\r\n            msg.sender,\r\n            amount,\r\n            safeAdd(block.number, depositTypes[depositType].blockDelay),\r\n            depositTypes[depositType].interestRateOnEnd,\r\n            depositTypes[depositType].interestRateBeforeEnd,\r\n            depositTypes[depositType].interestFee,\r\n            interestMultiplier,\r\n            depositTypes[depositType].closeable\r\n        );\r\n        require( success );\r\n        EventNewDeposit(DID, msg.sender);\r\n    }\r\n    function closeDeposit(address beneficary, uint256 DID) external checkSelf {\r\n        address _beneficary = beneficary;\r\n        if ( _beneficary == 0x00 ) {\r\n            _beneficary = msg.sender;\r\n        }\r\n        var (addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee,\r\n            interestM, closeable, valid) = TokenDB(databaseAddress).getDeposit(DID);\r\n        _closeDeposit(_beneficary, DID, deposits_s(addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee, interestM, closeable, valid));\r\n    }\r\n    /* Internals */\r\n    function _closeDeposit(address beneficary, uint256 DID, deposits_s data) internal {\r\n        require( data.valid \u0026\u0026 data.addr == msg.sender );\r\n        var (interest, interestFee) = _calculateInterest(data);\r\n        if ( interest \u003e 0 ) {\r\n            require( Token(tokenAddress).mint(beneficary, interest) );\r\n        }\r\n        if ( interestFee \u003e 0 ) {\r\n            require( Token(tokenAddress).mint(founderAddress, interestFee) );\r\n        }\r\n        require( TokenDB(databaseAddress).closeDeposit(DID) );\r\n        EventDepositClosed(DID, msg.sender, beneficary, interest, interestFee);\r\n    }\r\n    function _calculateInterest(deposits_s data) internal view returns (uint256 interest, uint256 interestFee) {\r\n        if ( ! data.valid || data.amount \u003c= 0 || data.end \u003c= data.start || block.number \u003c= data.start ) { return (0, 0); }\r\n        uint256 rate;\r\n        uint256 delay;\r\n        if ( data.end \u003c= block.number ) {\r\n            rate = data.interestOnEnd;\r\n            delay = safeSub(data.end, data.start);\r\n        } else {\r\n            require( data.closeable );\r\n            rate = data.interestBeforeEnd;\r\n            delay = safeSub(block.number, data.start);\r\n        }\r\n        if ( rate == 0 ) { return (0, 0); }\r\n        interest = safeDiv(safeMul(safeDiv(safeDiv(safeMul(data.amount, rate), 100), data.interestMultiplier), delay), safeSub(data.end, data.start));\r\n        if ( data.interestFee \u003e 0 \u0026\u0026 interest \u003e 0) {\r\n            interestFee = safeDiv(safeDiv(safeMul(interest, data.interestFee), 100), data.interestMultiplier);\r\n        }\r\n        if ( interestFee \u003e 0 ) {\r\n            interest = safeSub(interest, interestFee);\r\n        }\r\n    }\r\n    /* Constants */\r\n    function calculateInterest(uint256 DID) public view returns(uint256, uint256) {\r\n        var (addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee,\r\n            interestM, closeable, valid) = TokenDB(databaseAddress).getDeposit(DID);\r\n        return _calculateInterest(deposits_s(addr, amount, start, end, interestOnEnd, interestBeforeEnd, interestFee, interestM, closeable, valid));\r\n    }\r\n    /* Modifiers */\r\n    modifier checkSelf {\r\n        require( TokenDB(databaseAddress).tokenAddress() == tokenAddress );\r\n        require( TokenDB(databaseAddress).depositsAddress() == address(this) );\r\n        _;\r\n    }\r\n    /* Events */\r\n    event EventNewDepositType(uint256 indexed DTID, uint256 blockDelay, uint256 baseFunds,\r\n        uint256 interestRateOnEnd, uint256 interestRateBeforeEnd, uint256 interestFee, uint256 interestMultiplier, bool closeable);\r\n    event EventRevokeDepositType(uint256 indexed DTID);\r\n    event EventNewDeposit(uint256 indexed DID, address owner);\r\n    event EventDepositClosed(uint256 indexed DID, address owner, address beneficary, uint256 interest, uint256 interestFee);\r\n}\r\n"},"xgr_fork.sol":{"content":"/*\r\n    xgr_fork.sol\r\n    2.0.0\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_token.sol\";\r\nimport \"./xgr_owned.sol\";\r\n\r\ncontract Fork is Owned {\r\n    /* Variables */\r\n    address public uploader;\r\n    address public tokenAddress;\r\n    /* Constructor */\r\n    function Fork(address _uploader) public {\r\n        uploader = _uploader;\r\n    }\r\n    /* Externals */\r\n    function changeTokenAddress(address newTokenAddress) external onlyForOwner {\r\n        tokenAddress = newTokenAddress;\r\n    }\r\n    function upload(address[] addr, uint256[] amount) external onlyForUploader {\r\n        require( addr.length == amount.length );\r\n        for ( uint256 a=0 ; a\u003caddr.length ; a++ ) {\r\n            require( Token(tokenAddress).mint(addr[a], amount[a]) );\r\n        }\r\n    }\r\n    /* Modifiers */\r\n    modifier onlyForUploader {\r\n        require( msg.sender == uploader );\r\n        _;\r\n    }\r\n}\r\n"},"xgr_owned.sol":{"content":"/*\r\n    xgr_multiOwned.sol\r\n    2.0.0\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n*/\r\npragma solidity 0.4.18;\r\n\r\ncontract Owned {\r\n    /* Variables */\r\n    address public owner = msg.sender;\r\n    /* Externals */\r\n    function replaceOwner(address newOwner) external returns(bool success) {\r\n        require( isOwner() );\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n    /* Internals */\r\n    function isOwner() internal view returns(bool) {\r\n        return owner == msg.sender;\r\n    }\r\n    /* Modifiers */\r\n    modifier onlyForOwner {\r\n        require( isOwner() );\r\n        _;\r\n    }\r\n}\r\n"},"xgr_safeMath.sol":{"content":"/*\r\n    xgr_safeMath.sol\r\n    2.0.0\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n*/\r\npragma solidity 0.4.18;\r\n\r\ncontract SafeMath {\r\n    /* Internals */\r\n    function safeAdd(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if ( b \u003e 0 ) {\r\n            assert( a + b \u003e a );\r\n        }\r\n        return a + b;\r\n    }\r\n    function safeSub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if ( b \u003e 0 ) {\r\n            assert( a - b \u003c a );\r\n        }\r\n        return a - b;\r\n    }\r\n    function safeMul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    function safeDiv(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        return a / b;\r\n    }\r\n}\r\n"},"xgr_sample.sol":{"content":"/*\r\n    xgr_sample.sol\r\n    2.0.0\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n    \r\n    This is a sample contract for developing for XGR token. Use with your responsibility!\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_token.sol\";\r\nimport \"./xgr_safeMath.sol\";\r\nimport \"./xgr_owned.sol\";\r\n\r\ncontract SampleContract is Owned, SafeMath {\r\n    /* Variables */\r\n    mapping(address =\u003e uint256) public deposits; // Database of users balance\r\n    address public XGRAddress; // XGR Token address, please do not change this variable name!\r\n    /* Constructor */\r\n    function SampleContract(address newXGRTokenAddress) public {\r\n        /*\r\n            For the first time you need set the XGR token address.\r\n            The contract deployer would be also the owner.\r\n        */\r\n        XGRAddress = newXGRTokenAddress;\r\n    }\r\n    /* Externals */\r\n    function receiveToken(address addr, uint256 amount, bytes data) external onlyFromXGRToken returns(bool, uint256) {\r\n        /*\r\n            @addr has send @amount to ourself. The second return parameter is the refund amount.\r\n            If you don\u0027t need the whole amount, you can refund that for the address instantly.\r\n            Please do not change this function name and parameter!\r\n        */\r\n        incomingToken(addr, amount);\r\n        return (true, 0);\r\n    }\r\n    function approvedToken(address addr, uint256 amount, bytes data) external onlyFromXGRToken returns(bool) {\r\n        /*\r\n            @addr has allowed @amount for withdraw from her/his balance. We withdraw that to ourself.\r\n            Please do not change this function name and parameter!\r\n        */\r\n        require( Token(XGRAddress).transferFrom(addr, address(this), amount) );\r\n        incomingToken(addr, amount);\r\n        return true;\r\n    }\r\n    function changeTokenAddress(address newTokenAddress) external onlyForOwner {\r\n        /*\r\n            Maybe the XGR token contract becomes new address, you need maintenance this.\r\n        */\r\n        XGRAddress = newTokenAddress;\r\n    }\r\n    function killThisContract() external onlyForOwner {\r\n        var balance = Token(XGRAddress).balanceOf(address(this)); // get this contract XGR balance\r\n        require( Token(XGRAddress).transfer(msg.sender, balance) ); // send all XGR token to the caller\r\n        selfdestruct(msg.sender); // destruct the contract;\r\n    }\r\n    function withdraw(uint256 amount) external {\r\n        /*\r\n            Some users withdraw XGR token from this contract.\r\n            The contract must pay the XGR token fee, we need to reduce that from the amount;\r\n        */\r\n        var (success, fee) = Token(XGRAddress).getTransactionFee(amount); // Get the transfer fee from the contract\r\n        require( success );\r\n        withdrawToken(msg.sender, amount);\r\n        require( Token(XGRAddress).transfer(msg.sender, safeSub(amount, fee)) );\r\n    }\r\n    /* Internals */\r\n    function incomingToken(address addr, uint256 amount) internal {\r\n        deposits[addr] = safeAdd(deposits[addr], amount);\r\n    }\r\n    function withdrawToken(address addr, uint256 amount) internal {\r\n        deposits[addr] = safeSub(deposits[addr], amount);\r\n    }\r\n    /* Modifiers */\r\n    modifier onlyFromXGRToken {\r\n        require( msg.sender == XGRAddress );\r\n        _;\r\n    }\r\n}\r\n"},"xgr_token.sol":{"content":"/*\r\n    Gold Reserve Token\r\n    \r\n    xgr_token.sol\r\n    3.0.0\r\n    \r\n    Fusion Solutions KFT \u003ccontact@fusionsolutions.io\u003e\r\n    \r\n    Written by Andor Rajci, November 2018\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_token_db.sol\";\r\nimport \"./xgr_token_lib.sol\";\r\nimport \"./xgr_deposits.sol\";\r\nimport \"./xgr_fork.sol\";\r\nimport \"./xgr_safeMath.sol\";\r\nimport \"./xgr_owned.sol\";\r\nimport \"./xgr_sample.sol\";\r\n\r\ncontract Token is SafeMath, Owned {\r\n    /**\r\n    * @title Gold Reserve [XGR] token\r\n    */\r\n    /* Variables */\r\n    string  public name = \"GoldReserve\";\r\n    string  public symbol = \"XGR\";\r\n    uint8   public decimals = 8;\r\n    uint256 public transactionFeeRate   = 20; // 0.02 %\r\n    uint256 public transactionFeeRateM  = 1e3; // 1000\r\n    uint256 public transactionFeeMin    =   2000000; // 0.2 XGR\r\n    uint256 public transactionFeeMax    = 200000000; // 2.0 XGR\r\n    address public databaseAddress;\r\n    address public depositsAddress;\r\n    address public forkAddress;\r\n    address public libAddress;\r\n    /* Constructor */\r\n    function Token(address newDatabaseAddress, address newDepositAddress, address newFrokAddress, address newLibAddress) public {\r\n        databaseAddress = newDatabaseAddress;\r\n        depositsAddress = newDepositAddress;\r\n        forkAddress = newFrokAddress;\r\n        libAddress = newLibAddress;\r\n    }\r\n    /* Fallback */\r\n    function () {\r\n        revert();\r\n    }\r\n    /* Externals */\r\n    function changeDataBaseAddress(address newDatabaseAddress) external onlyForOwner {\r\n        databaseAddress = newDatabaseAddress;\r\n    }\r\n    function changeDepositsAddress(address newDepositsAddress) external onlyForOwner {\r\n        depositsAddress = newDepositsAddress;\r\n    }\r\n    function changeForkAddress(address newForkAddress) external onlyForOwner {\r\n        forkAddress = newForkAddress;\r\n    }\r\n    function changeLibAddress(address newLibAddress) external onlyForOwner {\r\n        libAddress = newLibAddress;\r\n    }\r\n    function changeFees(uint256 rate, uint256 rateMultiplier, uint256 min, uint256 max) external onlyForOwner {\r\n        transactionFeeRate = rate;\r\n        transactionFeeRateM = rateMultiplier;\r\n        transactionFeeMin = min;\r\n        transactionFeeMax = max;\r\n    }\r\n    /**\r\n     * @notice `msg.sender` approves `spender` to spend `amount` tokens on its behalf.\r\n     * @param spender The address of the account able to transfer the tokens\r\n     * @param amount The amount of tokens to be approved for transfer\r\n     * @return True if the approval was successful\r\n     */\r\n    function approve(address spender, uint256 amount) external returns (bool _success) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @notice Send `amount` tokens to `to` from `msg.sender`\r\n     * @param to The address of the recipient\r\n     * @param amount The amount of tokens to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address to, uint256 amount) external returns (bool success) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @notice Send `amount` tokens to `to` from `from` on the condition it is approved by `from`\r\n     * @param from The address holding the tokens being transferred\r\n     * @param to The address of the recipient\r\n     * @param amount The amount of tokens to be transferred\r\n     * @return True if the transfer was successful\r\n     */\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @notice Send `amount` tokens to `to` from `msg.sender` and notify the receiver from your transaction with your `extraData` data\r\n     * @param to The contract address of the recipient\r\n     * @param amount The amount of tokens to be transferred\r\n     * @param extraData Data to give forward to the receiver\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address to, uint256 amount, bytes extraData) external returns (bool success) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    function mint(address owner, uint256 value) external returns (bool success) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    /* Internals */\r\n    /* Constants */\r\n    function allowance(address owner, address spender) public constant returns (uint256 remaining, uint256 nonce) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x40)\r\n            }\r\n        }\r\n    }\r\n    function getTransactionFee(uint256 value) public constant returns (bool success, uint256 fee) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x40)\r\n            }\r\n        }\r\n    }\r\n    function balanceOf(address owner) public constant returns (uint256 value) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    function balancesOf(address owner) public constant returns (uint256 balance, uint256 lockedAmount) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x40)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x40)\r\n            }\r\n        }\r\n    }\r\n    function totalSupply() public constant returns (uint256 value) {\r\n        address _trg = libAddress;\r\n        assembly {\r\n            let m := mload(0x40)\r\n            calldatacopy(m, 0, calldatasize)\r\n            let success := delegatecall(gas, _trg, m, calldatasize, m, 0x20)\r\n            switch success case 0 {\r\n                revert(0, 0)\r\n            } default {\r\n                return(m, 0x20)\r\n            }\r\n        }\r\n    }\r\n    /* Events */\r\n    event AllowanceUsed(address indexed spender, address indexed owner, uint256 indexed value);\r\n    event Mint(address indexed addr, uint256 indexed value);\r\n    event Burn(address indexed addr, uint256 indexed value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Transfer2(address indexed from, address indexed to, uint256 indexed value, bytes data);\r\n}\r\n"},"xgr_token_db.sol":{"content":"/*\r\n    xgr_token_db.sol\r\n    2.0.0\r\n    \r\n    Rajci \u0027iFA\u0027 Andor @ ifa@fusionwallet.io\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_safeMath.sol\";\r\nimport \"./xgr_owned.sol\";\r\n\r\ncontract TokenDB is SafeMath, Owned {\r\n    /* Structures */\r\n    struct allowance_s {\r\n        uint256 amount;\r\n        uint256 nonce;\r\n    }\r\n    struct deposits_s {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 start;\r\n        uint256 end;\r\n        uint256 interestOnEnd;\r\n        uint256 interestBeforeEnd;\r\n        uint256 interestFee;\r\n        uint256 interestMultiplier;\r\n        bool    closeable;\r\n        bool    valid;\r\n    }\r\n    /* Variables */\r\n    mapping(address =\u003e mapping(address =\u003e allowance_s)) public allowance;\r\n    mapping(address =\u003e uint256) public balanceOf;\r\n    mapping(uint256 =\u003e deposits_s) private deposits;\r\n    mapping(address =\u003e uint256) public lockedBalances;\r\n    address public tokenAddress;\r\n    address public depositsAddress;\r\n    uint256 public depositsCounter;\r\n    uint256 public totalSupply;\r\n    /* Constructor */\r\n    /* Externals */\r\n    function changeTokenAddress(address newTokenAddress) external onlyForOwner {\r\n        tokenAddress = newTokenAddress;\r\n    }\r\n    function changeDepositsAddress(address newDepositsAddress) external onlyForOwner {\r\n        depositsAddress = newDepositsAddress;\r\n    }\r\n    function openDeposit(address addr, uint256 amount, uint256 end, uint256 interestOnEnd,\r\n        uint256 interestBeforeEnd, uint256 interestFee, uint256 multiplier, bool closeable) external onlyForDeposits returns(bool success, uint256 DID) {\r\n        depositsCounter += 1;\r\n        DID = depositsCounter;\r\n        lockedBalances[addr] = safeAdd(lockedBalances[addr], amount);\r\n        deposits[DID] = deposits_s(\r\n            addr,\r\n            amount,\r\n            block.number,\r\n            end,\r\n            interestOnEnd,\r\n            interestBeforeEnd,\r\n            interestFee,\r\n            multiplier,\r\n            closeable,\r\n            true\r\n        );\r\n        return (true, DID);\r\n    }\r\n    function closeDeposit(uint256 DID) external onlyForDeposits returns (bool success) {\r\n        require( deposits[DID].valid );\r\n        delete deposits[DID].valid;\r\n        lockedBalances[deposits[DID].addr] = safeSub(lockedBalances[deposits[DID].addr], deposits[DID].amount);\r\n        return true;\r\n    }\r\n    function transfer(address from, address to, uint256 amount, uint256 fee) external onlyForToken returns(bool success) {\r\n        balanceOf[from] = safeSub(balanceOf[from], safeAdd(amount, fee));\r\n        balanceOf[to] = safeAdd(balanceOf[to], amount);\r\n        totalSupply = safeSub(totalSupply, fee);\r\n        return true;\r\n    }\r\n    function increase(address owner, uint256 value) external onlyForToken returns(bool success) {\r\n        balanceOf[owner] = safeAdd(balanceOf[owner], value);\r\n        totalSupply = safeAdd(totalSupply, value);\r\n        return true;\r\n    }\r\n    function decrease(address owner, uint256 value) external onlyForToken returns(bool success) {\r\n        require( safeSub(balanceOf[owner], safeAdd(lockedBalances[owner], value)) \u003e= 0 );\r\n        balanceOf[owner] = safeSub(balanceOf[owner], value);\r\n        totalSupply = safeSub(totalSupply, value);\r\n        return true;\r\n    }\r\n    function setAllowance(address owner, address spender, uint256 amount, uint256 nonce) external onlyForToken returns(bool success) {\r\n        allowance[owner][spender].amount = amount;\r\n        allowance[owner][spender].nonce = nonce;\r\n        return true;\r\n    }\r\n    /* Constants */\r\n    function getAllowance(address owner, address spender) public constant returns(bool success, uint256 remaining, uint256 nonce) {\r\n        return ( true, allowance[owner][spender].amount, allowance[owner][spender].nonce );\r\n    }\r\n    function getDeposit(uint256 UID) public constant returns(address addr, uint256 amount, uint256 start,\r\n        uint256 end, uint256 interestOnEnd, uint256 interestBeforeEnd, uint256 interestFee, uint256 interestMultiplier, bool closeable, bool valid) {\r\n        addr = deposits[UID].addr;\r\n        amount = deposits[UID].amount;\r\n        start = deposits[UID].start;\r\n        end = deposits[UID].end;\r\n        interestOnEnd = deposits[UID].interestOnEnd;\r\n        interestBeforeEnd = deposits[UID].interestBeforeEnd;\r\n        interestFee = deposits[UID].interestFee;\r\n        interestMultiplier = deposits[UID].interestMultiplier;\r\n        closeable = deposits[UID].closeable;\r\n        valid = deposits[UID].valid;\r\n    }\r\n    /* Modifiers */\r\n    modifier onlyForToken {\r\n        require( msg.sender == tokenAddress );\r\n        _;\r\n    }\r\n    modifier onlyForDeposits {\r\n        require( msg.sender == depositsAddress );\r\n        _;\r\n    }\r\n}\r\n"},"xgr_token_lib.sol":{"content":"/*\r\n    Gold Reserve Token\r\n    \r\n    xgr_token_lib.sol\r\n    3.1.0\r\n    \r\n    Fusion Solutions KFT \u003ccontact@fusionsolutions.io\u003e\r\n    \r\n    Written by Andor Rajci, November 2018\r\n*/\r\npragma solidity 0.4.18;\r\n\r\nimport \"./xgr_token_db.sol\";\r\nimport \"./xgr_deposits.sol\";\r\nimport \"./xgr_fork.sol\";\r\nimport \"./xgr_safeMath.sol\";\r\nimport \"./xgr_owned.sol\";\r\nimport \"./xgr_sample.sol\";\r\n\r\ncontract TokenLib is SafeMath, Owned {\r\n    /**\r\n    * @title Gold Reserve [XGR] token\r\n    */\r\n    /* Variables */\r\n    string  public name = \"GoldReserve\";\r\n    string  public symbol = \"XGR\";\r\n    uint8   public decimals = 8;\r\n    uint256 public transactionFeeRate   = 20; // 0.02 %\r\n    uint256 public transactionFeeRateM  = 1e3; // 1000\r\n    uint256 public transactionFeeMin    =   2000000; // 0.2 XGR\r\n    uint256 public transactionFeeMax    = 200000000; // 2.0 XGR\r\n    address public databaseAddress;\r\n    address public depositsAddress;\r\n    address public forkAddress;\r\n    address public libAddress;\r\n    /* Constructor */\r\n    function TokenLib(address newDatabaseAddress, address newDepositAddress, address newFrokAddress, address newLibAddress) public {\r\n        databaseAddress = newDatabaseAddress;\r\n        depositsAddress = newDepositAddress;\r\n        forkAddress = newFrokAddress;\r\n        libAddress = newLibAddress;\r\n    }\r\n    /* Fallback */\r\n    function () public {\r\n        revert();\r\n    }\r\n    /* Externals */\r\n    function changeDataBaseAddress(address newDatabaseAddress) external onlyForOwner {\r\n        databaseAddress = newDatabaseAddress;\r\n    }\r\n    function changeDepositsAddress(address newDepositsAddress) external onlyForOwner {\r\n        depositsAddress = newDepositsAddress;\r\n    }\r\n    function changeForkAddress(address newForkAddress) external onlyForOwner {\r\n        forkAddress = newForkAddress;\r\n    }\r\n    function changeLibAddress(address newLibAddress) external onlyForOwner {\r\n        libAddress = newLibAddress;\r\n    }\r\n    function changeFees(uint256 rate, uint256 rateMultiplier, uint256 min, uint256 max) external onlyForOwner {\r\n        transactionFeeRate = rate;\r\n        transactionFeeRateM = rateMultiplier;\r\n        transactionFeeMin = min;\r\n        transactionFeeMax = max;\r\n    }\r\n    function approve(address spender, uint256 amount) external returns (bool success) {\r\n        _approve(spender, amount);\r\n        return true;\r\n    }\r\n    function transfer(address to, uint256 amount) external returns (bool success) {\r\n        bytes memory _data;\r\n        _transfer(msg.sender, to, amount, true, _data);\r\n        return true;\r\n    }\r\n    function transferFrom(address from, address to, uint256 amount) external returns (bool success) {\r\n        if ( from != msg.sender ) {\r\n            var (_success, _reamining, _nonce) = TokenDB(databaseAddress).getAllowance(from, msg.sender);\r\n            require( _success );\r\n            _reamining = safeSub(_reamining, amount);\r\n            _nonce = safeAdd(_nonce, 1);\r\n            require( TokenDB(databaseAddress).setAllowance(from, msg.sender, _reamining, _nonce) );\r\n            AllowanceUsed(msg.sender, from, amount);\r\n        }\r\n        bytes memory _data;\r\n        _transfer(from, to, amount, true, _data);\r\n        return true;\r\n    }\r\n    function transfer(address to, uint256 amount, bytes extraData) external returns (bool success) {\r\n        _transfer(msg.sender, to, amount, true, extraData);\r\n        return true;\r\n    }\r\n    function mint(address owner, uint256 value) external returns (bool success) {\r\n        require( msg.sender == forkAddress || msg.sender == depositsAddress );\r\n        _mint(owner, value);\r\n        return true;\r\n    }\r\n    /* Internals */\r\n    function _transfer(address from, address to, uint256 amount, bool fee, bytes extraData) internal {\r\n        bool _success;\r\n        uint256 _fee;\r\n        uint256 _payBack;\r\n        uint256 _amount = amount;\r\n        uint256 balance = TokenDB(databaseAddress).balanceOf(from);\r\n        uint256 lockedBalance = TokenDB(databaseAddress).lockedBalances(from);\r\n        balance = safeSub(balance, lockedBalance);\r\n        require( _amount \u003e 0 \u0026\u0026 balance \u003e 0 );\r\n        require( from != 0x00 \u0026\u0026 to != 0x00 );\r\n        if( fee ) {\r\n            (_success, _fee) = getTransactionFee(amount);\r\n            require( _success );\r\n            if ( balance == amount ) {\r\n                _amount = safeSub(amount, _fee);\r\n            }\r\n        }\r\n        require( balance \u003e= safeAdd(_amount, _fee) );\r\n        if ( fee ) {\r\n            Burn(from, _fee);\r\n        }\r\n        Transfer(from, to, _amount);\r\n        Transfer2(from, to, _amount, extraData);\r\n        require( TokenDB(databaseAddress).transfer(from, to, _amount, _fee) );\r\n    }\r\n    function _mint(address owner, uint256 value) internal {\r\n        require( TokenDB(databaseAddress).increase(owner, value) );\r\n        Mint(owner, value);\r\n    }\r\n    function _approve(address spender, uint256 amount) internal {\r\n        require( msg.sender != spender );\r\n        require( TokenDB(databaseAddress).setAllowance(msg.sender, spender, amount, 0x00) );\r\n        Approval(msg.sender, spender, amount);\r\n    }\r\n    /* Constants */\r\n    function allowance(address owner, address spender) public constant returns (uint256 remaining, uint256 nonce) {\r\n        var (_success, _remaining, _nonce) = TokenDB(databaseAddress).getAllowance(owner, spender);\r\n        require( _success );\r\n        return (_remaining, _nonce);\r\n    }\r\n    function getTransactionFee(uint256 value) public constant returns (bool success, uint256 fee) {\r\n        fee = safeMul(value, transactionFeeRate) / transactionFeeRateM / 100;\r\n        if ( fee \u003e transactionFeeMax ) { fee = transactionFeeMax; }\r\n        else if ( fee \u003c transactionFeeMin ) { fee = transactionFeeMin; }\r\n        return (true, fee);\r\n    }\r\n    function balanceOf(address owner) public constant returns (uint256 value) {\r\n        return TokenDB(databaseAddress).balanceOf(owner);\r\n    }\r\n    function balancesOf(address owner) public constant returns (uint256 balance, uint256 lockedAmount) {\r\n        return (TokenDB(databaseAddress).balanceOf(owner), TokenDB(databaseAddress).lockedBalances(owner));\r\n    }\r\n    function totalSupply() public constant returns (uint256 value) {\r\n        return TokenDB(databaseAddress).totalSupply();\r\n    }\r\n    /* Events */\r\n    event AllowanceUsed(address indexed spender, address indexed owner, uint256 indexed value);\r\n    event Mint(address indexed addr, uint256 indexed value);\r\n    event Burn(address indexed addr, uint256 indexed value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Transfer2(address indexed from, address indexed to, uint256 indexed value, bytes data);\r\n}\r\n"}}