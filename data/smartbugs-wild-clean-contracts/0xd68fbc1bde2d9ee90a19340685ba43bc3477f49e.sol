{"DOS.sol":{"content":"pragma solidity 0.5.7;\n\nimport \"./SafeMath.sol\";\nimport \"./Utils.sol\";\n\ncontract ERC20 {\n    function allowance(address owner, address spender) public view returns (uint256);\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\n    function approve(address spender, uint256 value) public returns (bool);\n    function totalSupply() public view returns (uint256);\n    function balanceOf(address who) public view returns (uint256);\n    function transfer(address to, uint256 value) public returns (bool);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n    event Transfer(address indexed from, address indexed to, uint256 value);\n}\n\n/**\n * @title ERC677 transferAndCall token interface\n * @dev See https://github.com/ethereum/EIPs/issues/677 for specification and\n *      discussion.\n *\n * We deviate from the specification and we don\u0027t define a tokenfallback. That means\n * tranferAndCall can specify the function to call (bytes4(sha3(\"setN(uint256)\")))\n * and its arguments, and the respective function is called.\n *\n * If an invalid function is called, its default function (if implemented) is called.\n *\n * We also deviate from ERC865 and added a pre signed transaction for transferAndCall.\n */\n\n/*\n Notes on signature malleability: Ethereum took the same\n precaution as in bitcoin was used to prevent that:\n\n https://github.com/ethereum/go-ethereum/blob/master/vendor/github.com/btcsuite/btcd/btcec/signature.go#L48\n https://github.com/ethereum/go-ethereum/blob/master/crypto/signature_test.go\n https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md\n https://github.com/ethereum/EIPs/blob/master/EIPS/eip-2.md\n\n However, ecrecover still allows ambigous signatures. Thus, recover that wraps ecrecover checks for ambigous\n signatures and only allows unique signatures.\n*/\n\ncontract ERC865Plus677ish {\n    event TransferAndCall(address indexed _from, address indexed _to, uint256 _value, bytes4 _methodName, bytes _args);\n    function transferAndCall(address _to, uint256 _value, bytes4 _methodName, bytes memory _args) public returns (bytes memory);\n\n    event TransferPreSigned(address indexed _from, address indexed _to, address indexed _delegate,\n        uint256 _amount, uint256 _fee);\n    event TransferAndCallPreSigned(address indexed _from, address indexed _to, address indexed _delegate,\n        uint256 _amount, uint256 _fee, bytes4 _methodName, bytes _args);\n\n    function transferPreSigned(bytes memory _signature, address _to, uint256 _value,\n        uint256 _fee, uint256 _nonce) public returns (bool);\n    function transferAndCallPreSigned(bytes memory _signature, address _to, uint256 _value,\n        uint256 _fee, uint256 _nonce, bytes4 _methodName, bytes memory _args) public returns (bytes memory);\n}\n\ncontract DOS is ERC20, ERC865Plus677ish {\n    using SafeMath for uint256;\n\n    string public constant name = \"DOS Token\";\n    string public constant symbol = \"DOS\";\n    uint8 public constant decimals = 18;\n\n    mapping(address =\u003e uint256) private balances;\n    mapping(address =\u003e mapping(address =\u003e uint256)) private allowed;\n    // nonces of transfers performed\n    mapping(bytes =\u003e bool) private signatures;\n    mapping(address =\u003e mapping (uint256 =\u003e bool)) private nonces;\n    mapping(address =\u003e bool) private contractWhitelist;\n\n    uint256 private totalSupply_;\n    uint256 public constant maxSupply = 900000000 * (10 ** uint256(decimals));\n\n    // token lockups\n    mapping(address =\u003e uint256) private lockups;\n\n    // ownership\n    address public owner;\n    address public tmpOwner;\n    address public admin1;\n    address public admin2;\n\n    //3 admins can disable the transfers, however, the balances remain.\n    //this can be used to migrate to another contract. This flag can only\n    //be set by 3 admins.\n    bool public transfersEnabled1 = true;\n    bool public transfersEnabled2 = true;\n    bool public transfersEnabled3 = true;\n\n    // minting\n    bool public mintingDone = false;\n\n    //vesting variables, check dates with https://www.epochconverter.com/ and https://www.unixtimestamp.com/\n    uint256 public constant firstFeb19 = 1548979200;\n    uint256 public constant sixMonth = 6 * 30 days;\n\n    event TokensLocked(address indexed _holder, uint256 _timeout);\n\n    constructor() public {\n        owner = msg.sender;\n    }\n\n    /**\n     * @dev Allows the current owner to transfer the ownership.\n     * @param _newOwner The address to transfer ownership to.\n     */\n    function transferOwnership(address _newOwner) public {\n        require(owner == msg.sender);\n        require(_newOwner != address(0));\n        require(_newOwner != admin1);\n        require(_newOwner != admin2);\n        require(_newOwner != owner); //sanity check\n\n        tmpOwner = _newOwner;\n    }\n\n    function claimOwnership() public {\n        require(tmpOwner == msg.sender);\n        owner = tmpOwner;\n        tmpOwner = address(0);\n    }\n\n    function setAdmin(address _admin1, address _admin2) public {\n        require(owner == msg.sender);\n        require(!mintingDone);\n        require(_admin1 != address(0));\n        require(_admin1 != owner);\n        require(_admin2 != address(0));\n        require(_admin2 != owner);\n        require(_admin1 != _admin2);\n\n        admin1 = _admin1;\n        admin2 = _admin2;\n    }\n\n    function addWhitelist(address contractAddress) public {\n        require(owner == msg.sender || admin1 == msg.sender || admin2 == msg.sender);\n\n        contractWhitelist[contractAddress] = true;\n    }\n\n    function removeWhitelist(address contractAddress) public {\n        require(owner == msg.sender || admin1 == msg.sender || admin2 == msg.sender);\n\n        delete contractWhitelist[contractAddress];\n    }\n\n    // minting functionality\n    function mint(address[] calldata _recipients, uint256[] calldata _amounts) external {\n        require(owner == msg.sender);\n        require(!mintingDone);\n        require(_recipients.length == _amounts.length);\n        require(_recipients.length \u003c= 255);\n\n        for (uint8 i = 0; i \u003c _recipients.length; i++) {\n            uint256 amount = _amounts[i];\n            totalSupply_ = totalSupply_.add(amount);\n            require(totalSupply_ \u003c= maxSupply); // enforce maximum token supply\n\n            address recipient = _recipients[i];\n            balances[recipient] = balances[recipient].add(amount);\n\n            emit Transfer(address(0), recipient, amount);\n        }\n    }\n\n    /**\n     * @param _sixMonthCliff Number of a six month cliff. E.g., 1 is for 6 month, 2 is for 12 month, 3 is for 18 month, etc.\n     */\n    function lockTokens(address[] calldata _holders, uint256[] calldata _sixMonthCliff) external {\n        require(owner == msg.sender);\n        require(!mintingDone);\n        require(_holders.length == _sixMonthCliff.length);\n        require(_holders.length \u003c= 255);\n\n        for (uint8 i = 0; i \u003c _holders.length; i++) {\n            address holder = _holders[i];\n            // make sure lockup period can not be overwritten\n            require(lockups[holder] == 0);\n\n            uint256 timeout = (_sixMonthCliff[i].mul(sixMonth)).add(firstFeb19);\n\n            lockups[holder] = timeout;\n            emit TokensLocked(holder, timeout);\n        }\n    }\n\n    //If this is called, no more tokens can be generated\n    //The status of the contract can be checked with getMintingDone, as\n    //this variable is set to public, thus, getters are generated automatically\n    function finishMinting() public {\n        require(owner == msg.sender);\n        require(!mintingDone);\n        require(admin1 != address(0));\n        require(admin2 != address(0));\n\n        mintingDone = true;\n    }\n\n    function transferDisable() public {\n        if(msg.sender == owner) {\n            transfersEnabled1 = false;\n        } else if(msg.sender == admin1) {\n            transfersEnabled2 = false;\n        } else if(msg.sender == admin2) {\n            transfersEnabled3 = false;\n        } else {\n            revert();\n        }\n    }\n\n    function isTransferEnabled() public view returns (bool) {\n        //all three must agree to disable the transfer\n        return transfersEnabled1 || transfersEnabled2 || transfersEnabled3;\n    }\n\n    /**\n    * @dev total number of tokens in existence, which is mandated by the ERC20 interface\n    */\n    function totalSupply() public view returns (uint256) {\n        return totalSupply_;\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        _transfer(msg.sender, _to, _value, 0, address(0));\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        _transfer(_from, _to, _value, 0, address(0));\n        _approve(_from, msg.sender, allowed[_from][msg.sender].sub(_value));\n        return true;\n    }\n\n    function _transfer(address _from, address _to, uint256 _value, uint256 _fee, address _feeAddress) internal {\n        require(isTransferEnabled());\n        require(_to != address(0));\n        require(_to != address(this));\n        uint256 total = _value.add(_fee);\n        require(mintingDone);\n        require(now \u003e= lockups[_from]); // check lockups\n        require(total \u003c= balances[_from]);\n\n        balances[_from] = balances[_from].sub(total);\n\n        if(_fee \u003e 0 \u0026\u0026 _feeAddress != address(0)) {\n            balances[_feeAddress] = balances[_feeAddress].add(_fee);\n        }\n\n        balances[_to] = balances[_to].add(_value);\n        emit Transfer(_from, _to, _value);\n    }\n\n    /**\n    * @dev Gets the balance of the specified address.\n    * @param _owner The address to query the the balance of.\n    * @return An uint256 representing the amount owned by the passed address.\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n\n\n    /**\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n     * race condition is to first reduce the spender\u0027s allowance to 0 and set the desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     * @param _spender The address which will spend the funds.\n     * @param _value The amount of tokens to be spent.\n     */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        _approve(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /**\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\n     * @param _owner address The address which owns the funds.\n     * @param _spender address The address which will spend the funds.\n     * @return A uint256 specifying the amount of tokens still available for the spender.\n     */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To increment\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param _spender The address which will spend the funds.\n     * @param _addedValue The amount of tokens to increase the allowance by.\n     */\n    function increaseAllowance(address _spender, uint256 _addedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].add(_addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\n     * approve should be called when _allowed[msg.sender][spender] == 0. To decrement\n     * allowed value is better to use this function to avoid 2 calls (and wait until\n     * the first transaction is mined)\n     * From MonolithDAO Token.sol\n     * Emits an Approval event.\n     * @param _spender The address which will spend the funds.\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\n     */\n    function decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool) {\n        _approve(msg.sender, _spender, allowed[msg.sender][_spender].sub(_subtractedValue));\n        return true;\n    }\n\n    /**\n     * @dev Approve an address to spend another addresses\u0027 tokens.\n     * @param _owner The address that owns the tokens.\n     * @param _spender The address that will spend the tokens.\n     * @param _value The number of tokens that can be spent.\n     */\n    function _approve(address _owner, address _spender, uint256 _value) internal {\n        require(_spender != address(0));\n        require(_owner != address(0));\n\n        allowed[_owner][_spender] = _value;\n        emit Approval(_owner, _spender, _value);\n    }\n\n    function transferAndCall(address _to, uint256 _value, bytes4 _methodName, bytes memory _args) public returns (bytes memory) {\n        require(contractWhitelist[_to]);\n        require(transfer(_to, _value));\n\n        emit TransferAndCall(msg.sender, _to, _value, _methodName, _args);\n\n        // call receiver\n        require(Utils.isContract(_to));\n\n        (bool success, bytes memory data) = _to.call(abi.encodePacked(abi.encodeWithSelector(_methodName, msg.sender, _value), _args));\n        require(success);\n        return data;\n    }\n\n    //ERC 865 + delegate transfer and call\n    //The signature only allows s \u003c secp256k1n / 2 and v to be 27/28\n    //If this is not the case the function will revert\n    function transferPreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce) public returns (bool) {\n\n        require(!signatures[_signature]);\n        bytes32 hashedTx = Utils.transferPreSignedHashing(address(this), _to, _value, _fee, _nonce);\n        address from = Utils.recover(hashedTx, _signature);\n\n        require(from != address(0));\n        require(!nonces[from][_nonce]);\n\n        _transfer(from, _to, _value, _fee, msg.sender);\n        signatures[_signature] = true;\n        nonces[from][_nonce] = true;\n\n        emit Transfer(from, msg.sender, _fee);\n        emit TransferPreSigned(from, _to, msg.sender, _value, _fee);\n        return true;\n    }\n\n    //The signature only allows s \u003c secp256k1n / 2 and v to be 27/28\n    //If this is not the case the function will revert\n    function transferAndCallPreSigned(bytes memory _signature, address _to, uint256 _value, uint256 _fee, uint256 _nonce,\n        bytes4 _methodName, bytes memory _args) public returns (bytes memory) {\n\n        require(contractWhitelist[_to]);\n        require(!signatures[_signature]);\n        bytes32 hashedTx = Utils.transferAndCallPreSignedHashing(address(this), _to, _value, _fee, _nonce, _methodName, _args);\n        address from = Utils.recover(hashedTx, _signature);\n\n        require(from != address(0));\n        require(!nonces[from][_nonce]);\n\n        _transfer(from, _to, _value, _fee, msg.sender);\n        signatures[_signature] = true;\n        nonces[from][_nonce] = true;\n\n        emit Transfer(from, msg.sender, _fee);\n        emit TransferAndCallPreSigned(from, _to, msg.sender, _value, _fee, _methodName, _args);\n\n        // call receiver\n        require(Utils.isContract(_to));\n\n        //call on behalf of from and not msg.sender\n        (bool success, bytes memory data) = _to.call(abi.encodePacked(abi.encodeWithSelector(_methodName, from, _value), _args));\n        require(success);\n        return data;\n    }\n}\n"},"SafeMath.sol":{"content":"//using: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/f80c65ff67957404c964af864ffb230e4cbb1cf4/contracts/math/SafeMath.sol\npragma solidity 0.5.7;\n\n/**\n * @title SafeMath\n * @dev Unsigned math operations with safety checks that revert on error\n */\nlibrary SafeMath {\n  /**\n  * @dev Multiplies two unsigned integers, reverts on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n    // benefit is lost if \u0027b\u0027 is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    uint256 c = a * b;\n    require(c / a == b);\n\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // Solidity only automatically asserts when dividing by 0\n    require(b \u003e 0);\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n    return c;\n  }\n\n  /**\n  * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b \u003c= a);\n    uint256 c = a - b;\n\n    return c;\n  }\n\n  /**\n  * @dev Adds two unsigned integers, reverts on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    require(c \u003e= a);\n\n    return c;\n  }\n\n  /**\n  * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\n  * reverts when dividing by zero.\n  */\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n    require(b != 0);\n    return a % b;\n  }\n}\n"},"Utils.sol":{"content":"pragma solidity 0.5.7;\n\nlibrary Utils {\n\n    //From: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/AddressUtils.sol\n\n    /**\n    * Returns whether the target address is a contract\n    * @dev This function will return false if invoked during the constructor of a contract,\n    *  as the code is not actually created until after the constructor finishes.\n    * @param addr address to check\n    * @return whether the target address is a contract\n    */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(addr) }\n        return size \u003e 0;\n    }\n\n    //From: https://github.com/PROPSProject/props-token-distribution/blob/master/contracts/token/ERC865Token.sol\n    //adapted to: https://solidity.readthedocs.io/en/v0.5.3/050-breaking-changes.html?highlight=abi%20encode\n\n    /**\n     * @notice Hash (keccak256) of the payload used by transferPreSigned\n     * @param _token address The address of the token.\n     * @param _to address The address which you want to transfer to.\n     * @param _value uint256 The amount of tokens to be transferred.\n     * @param _fee uint256 The amount of tokens paid to msg.sender, by the owner.\n     */\n    function transferAndCallPreSignedHashing(address _token, address _to, uint256 _value, uint256 _fee, uint256 _nonce,\n        bytes4 _methodName, bytes memory _args) internal pure returns (bytes32) {\n        /* \"38980f82\": transferAndCallPreSignedHashing(address,address,uint256,uint256,uint256,bytes4,bytes) */\n        return keccak256(abi.encode(bytes4(0x38980f82), _token, _to, _value, _fee, _nonce, _methodName, _args));\n    }\n\n    function transferPreSignedHashing(address _token, address _to, uint256 _value, uint256 _fee, uint256 _nonce)\n    internal pure returns (bytes32) {\n        /* \"15420b71\": transferPreSignedHashing(address,address,uint256,uint256,uint256) */\n        return keccak256(abi.encode(bytes4(0x15420b71), _token, _to, _value, _fee, _nonce));\n    }\n\n    //From: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/cryptography/ECDSA.sol\n\n    /**\n     * @dev Recover signer address from a message by using their signature\n     * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\n     * @param signature bytes signature, the signature is generated using web3.eth.sign()\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            return (address(0));\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 \u003c s \u003c secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) \u003e 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return address(0);\n        }\n\n        if (v != 27 \u0026\u0026 v != 28) {\n            return address(0);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        return ecrecover(hash, v, r, s);\n    }\n}\n"}}