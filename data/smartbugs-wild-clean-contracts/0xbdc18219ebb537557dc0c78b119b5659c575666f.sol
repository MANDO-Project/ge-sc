{"AuctionityLibrary_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityStorage0.sol\";\n\n/// @title Auction library for delegate for some delegated function\ncontract AuctionityLibrary_V1 is AuctionityStorage0 {\n    /// @notice get delegated addrss from a selector\n    /// @param _selector byte4\n    /// @return _contractDelegate address\n    function getDelegate_V1(bytes4 _selector)\n        public\n        view\n        returns (address _contractDelegate)\n    {\n        return delegates[_selector];\n    }\n\n    /// @notice call delegated function\n    /// @param _calldata bytes : data sended to delegated contract\n    /// @param _contractFallback address: address of fallback if selector is not exist, address(0) if no fallback\n    /// @return uint return pointer and uint return size of callData return\n    function _callDelegated_V1(\n        bytes memory _calldata,\n        address _contractFallback\n    ) internal returns (uint returnPtr, uint returnSize) {\n        /// @dev get selector from _calldata\n        bytes4 _selector;\n        assembly {\n            _selector := mload(add(_calldata, 0x20))\n        }\n\n        /// @dev get address of delegated from selector\n        address _contractDelegate = getDelegate_V1(_selector);\n\n        /// @dev if _contractDelegate not found set _contractFallback into _contractFallback\n        if (_contractDelegate == address(0)) {\n            _contractDelegate = _contractFallback;\n        }\n\n        require(\n            _contractDelegate != address(0),\n            \"Auctionity function does not exist.\"\n        );\n\n        /// @dev delegate call and return result, or the eventual revert\n        assembly {\n            let result := delegatecall(\n                gas,\n                _contractDelegate,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            returnSize := returndatasize\n            returnPtr := mload(0x40)\n            returndatacopy(returnPtr, 0, returnSize)\n            if eq(result, 0) {\n                revert(returnPtr, returnSize)\n            }\n        }\n\n        /// @dev return returndatacopy\n        return (returnPtr, returnSize);\n\n    }\n\n    /// @notice delegate IsContractOwner_V1\n    /// @return  _isContractOwner\n    function delegatedSendIsContractOwner_V1()\n        public\n        returns (bool _isContractOwner)\n    {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveIsContractOwner_V1()\"))\n            ),\n            address(0)\n        );\n\n        assembly {\n            _isContractOwner := mload(returnPtr)\n        }\n\n        return _isContractOwner;\n    }\n\n    modifier delegatedSendIsOracle_V1() {\n        require(\n            msg.sender == delegatedSendGetOracle_V1(),\n            \"Sender must be oracle\"\n        );\n        _;\n    }\n\n    /// @notice delegate getOracle_V1\n    /// @return address _oracle\n    function delegatedSendGetOracle_V1() public returns (address _oracle) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveGetOracle_V1()\"))\n            ),\n            address(0)\n        );\n\n        assembly {\n            _oracle := mload(returnPtr)\n        }\n        return _oracle;\n\n    }\n\n    /// @notice delegate getPaused_V1\n    /// @return bool _isPaused\n    function delegatedSendGetPaused_V1() public returns (bool _isPaused) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(keccak256(\"delegatedReceiveGetPaused_V1()\"))\n            ),\n            address(0)\n        );\n        assembly {\n            _isPaused := mload(returnPtr)\n        }\n        return _isPaused;\n\n    }\n\n    /// @notice delegate lockDeposit_V1\n    /// @param _tokenContractAddress address\n    /// @param _tokenId uint256\n    /// @param _amount uint256\n    /// @param _auctionId uint256\n    /// @param _refundUser address\n    /// @return bool _isPaused\n    function delegatedLockDeposit_V1(\n        address _tokenContractAddress,\n        uint256 _tokenId,\n        uint256 _amount,\n        uint256 _auctionId,\n        address _refundUser\n    ) public returns (bool _success) {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            abi.encodeWithSelector(\n                bytes4(\n                    keccak256(\n                        \"lockDeposit_V1(address,uint256,uint256,uint256,address)\"\n                    )\n                ),\n                _tokenContractAddress,\n                _tokenId,\n                _amount,\n                _auctionId,\n                _refundUser\n            ),\n            address(0)\n        );\n\n        assembly {\n            _success := mload(returnPtr)\n        }\n        return _success;\n\n    }\n\n    /// @notice verify if _contractAddress is a contract\n    /// @param _contractAddress address\n    /// @return _isContract\n    function isContract_V1(address _contractAddress)\n        internal\n        view\n        returns (bool _isContract)\n    {\n        uint _size;\n        assembly {\n            _size := extcodesize(_contractAddress)\n        }\n        return _size \u003e 0;\n    }\n\n    /// @notice cast a bytesmemory into a uint256\n    /// @param b bytes\n    /// @return uint256\n    function bytesToUint_V1(bytes memory b) internal pure returns (uint256) {\n        uint256 _number;\n        for (uint i = 0; i \u003c b.length; i++) {\n            _number = _number + uint8(b[i]) * (2 ** (8 * (b.length - (i + 1))));\n        }\n        return _number;\n    }\n}\n"},"AuctionityProxy_V1.sol":{"content":"pragma solidity ^0.5.4;\n\nimport \"./AuctionityLibrary_V1.sol\";\n\n/**\n * @title Proxy\n * @dev Gives the possibility to delegate any call to a foreign implementation.\n */\ncontract AuctionityProxy_V1 is AuctionityLibrary_V1 {\n    /// @notice init contract by calling `_auctionityProxyUpdate.initProxyContract_V1(auctionityProxyUpdate,_ownable)`,\n    /// adding the first delegate functions and set _ownable as the contract responsible for\n    /// contract ownership.\n    /// @param _auctionityProxyUpdate address : contract proxyUpdate\n    /// @param _ownable address : contract ownable\n    constructor(address _auctionityProxyUpdate, address _ownable) public {\n        /// @dev encode initProxyContract_V1 selector with parametters\n        bytes memory _calldata = abi.encodeWithSelector(\n            bytes4(keccak256(\"initProxyContract_V1(address,address)\")),\n            _auctionityProxyUpdate,\n            _ownable\n        );\n\n        /// @dev deletatecall initProxyContract_V1 to _auctionityProxyUpdate\n        /// @return return the delegtecall return, or the eventual revert\n        assembly {\n            let result := delegatecall(\n                gas,\n                _auctionityProxyUpdate,\n                add(_calldata, 0x20),\n                mload(_calldata),\n                0,\n                0\n            )\n            let size := returndatasize\n            returndatacopy(_calldata, 0, size)\n            if eq(result, 0) {\n                revert(_calldata, size)\n            }\n        }\n    }\n\n    // @notice Fallback payable proxy function\n    /// @return return the _callDelegated_V1 return, or the eventual revert\n    function() external payable {\n        uint returnPtr;\n        uint returnSize;\n\n        (returnPtr, returnSize) = _callDelegated_V1(\n            msg.data,\n            proxyFallbackContract\n        );\n\n        assembly {\n            return(returnPtr, returnSize)\n        }\n\n    }\n}\n"},"AuctionityStorage0.sol":{"content":"pragma solidity ^0.5.4;\n\ncontract AuctionityStorage0 {\n    // selector =\u003e delegate contract\n    mapping(bytes4 =\u003e address) internal delegates;\n\n    // If selector not found, fallback contract address\n    address public proxyFallbackContract;\n\n    address public contractOwner;\n    address public oracle;\n\n    bool public paused;\n\n    uint8 public ethereumChainId;\n    uint8 public auctionityChainId;\n}\n"}}