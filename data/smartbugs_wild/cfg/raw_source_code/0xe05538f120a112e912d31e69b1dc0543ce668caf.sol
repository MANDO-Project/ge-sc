{"LVToken.sol":{"content":"pragma solidity ^0.4.11;\n\nimport \"./SafeMath.sol\";\n\ncontract LVToken {\n    using SafeMath for uint;\n\n    string public constant name = \"LivesToken on Chain\";\n    string public constant symbol = \"LVTC\";\n    uint8 public constant decimals = 18;\n    string public constant version = \"1.0\";\n\n    mapping (address =\u003e uint) balances;\n    mapping (address =\u003e mapping (address =\u003e uint)) allowed;\n\n    bool public freezed = false;\n    mapping (address =\u003e uint) permits;\n    address public constant addr_team = 0xd5a375Dd13abEF145B8183E6C2380BC777614395;\n    address public constant addr_miner = 0x22164b69c71DcF12E1dc037BB43933449f342a69;\n    address public constant addr_ico = 0xBDC44A4EA8A9640ee5DcF2E0425d7A262C830c62;\n    address public constant addr_org = 0x32A3A725895F1BdcFC1FEf8340f9f26d49Af60ab;\n\n    //28 billion total\n    uint public totalSupply = 28 * (10**9) * (10**uint(decimals));\n\n    event Transfer(address indexed _from, address indexed _to, uint _value);\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\n    event Freeze(address indexed _from, uint _sum);\n\n    function LVToken() public {\n        balances[addr_team] = 28 * (10**8) * (10**uint(decimals));              //team, 10%\n        balances[addr_miner] = 140 * (10**8) * (10**uint(decimals));             //miner, 50%\n        balances[addr_ico] = 56 * (10**8) * (10**uint(decimals));              //pre-ico, 20%\n        balances[addr_org] = 56 * (10**8) * (10**uint(decimals));              //organization, 20%\n\n        permits[addr_team] = 0;\n        permits[addr_miner] = 0;\n        permits[addr_ico] = 0;\n        permits[addr_org] = 0;\n    }\n\n    function transfer(address _to, uint _value) public returns (bool) {\n        require(!freezed);\n        require(_value \u003e 0);\n\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool) {\n        require(!freezed);\n        require(_value \u003e 0);\n\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    function balanceOf(address _owner) constant public returns (uint) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint _value) public returns (bool) {\n        require(!freezed);\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n        \n        allowed[msg.sender][_spender] = _value;\n\n        emit Approval(msg.sender, _spender, _value);\n\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant public returns (uint) {\n        return allowed[_owner][_spender];\n    }\n\n    /**\n     * as we are going to 1:1 swap to LVT-chain in the future, all the transactions in ethereum will be freezed at that time\n     */    \n    function freeze() public {\n        //this function is allowed before freezed\n        require(!freezed);\n        //only the pre-allocated address can run this function\n        require((msg.sender == addr_team) || (msg.sender == addr_miner) || (msg.sender == addr_ico) || (msg.sender == addr_org));\n        //set to 1 of the caller\n        permits[msg.sender] = 1;\n        //sum all the addresses\u0027s setting\n        uint sum = permits[addr_team] + permits[addr_miner] + permits[addr_ico] + permits[addr_org];\n        if (sum \u003e= 2) {\n            //the token is freezed if at least 2 address has run this function\n            freezed = true;\n        }\n        emit Freeze(msg.sender, sum);\n    }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.11;\n\n\nlibrary SafeMath {\n    /*\n    function mul(uint a, uint b) pure internal returns (uint) {\n        if (a == 0) {\n            return 0;\n        }\n        uint c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    function div(uint a, uint b) pure internal returns (uint) {\n        require(b \u003e 0);\n        uint c = a / b;\n        return c;\n    }\n    */\n\n    function sub(uint a, uint b) pure internal returns (uint) {\n        assert(b \u003c= a);\n        return a - b;\n    }\n\n    function add(uint a, uint b) pure internal returns (uint) {\n        uint c = a + b;\n        assert(c \u003e= a);\n        return c;\n    }\n}\n"}}