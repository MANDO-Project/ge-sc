{"AgreementManager.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./SafeUtils.sol\";\nimport \"./EvidenceProducer.sol\";\n\n/**\n    @notice\n    AgreementManager allows two parties (A and B) to represent some sort of agreement that\n    involves staking ETH. The general flow is: they both deposit a stake (they can withdraw until\n    both stakes have been deposited), then their agreement is either fulfilled or not based on\n    actions outside of this contract, then either party can \"resolve\" by specifying how they think\n    funds should be split based on each party\u0027s actions in relation to the agreement terms.\n    Funds are automatically dispersed once there\u0027s a resolution. If the parties disagree, they can\n    summon a predefined arbitrator to settle their dispute.\n\n    @dev\n    There are several types of AgreementManager which inherit from this contract. The inheritance\n    tree looks like:\n    AgreementManager\n        AgreementManagerETH\n            AgreementManagerETH_Simple\n            AgreementManagerETH_ERC792\n        AgreementManagerERC20\n            AgreementManagerERC20_Simple\n            AgreementManagerERC792_Simple\n\n    Essentially there are two options:\n    (1) Does the agreement use exclusively ETH, or also at least one ERC20 Token?\n    (2) Does the agreement use simple arbitration (an agreed upon external address), or ERC792\n        (Kleros) arbitration?\n    There are four contracts, one for each combination of options, although much of their code is\n    shared. AgreementManagerERC20 can handle purely ETH agreements, but it\u0027s cheaper to use\n    AgreementManagerETH.\n\n    To avoid comment duplication, comments have been pushed as high in the inheritance tree as\n    possible. Several functions are declared for the first time in AgreementManagerETH and\n    AgreementManagerERC20 rather than in AgreementManager, because they take slightly different\n    arguments.\n\n    **** NOTES ON REENTRANCY ****\n\n    For ease of review, functions that call untrusted external functions (even via multiple calls)\n    and which have these external calls wrapped in a reentrancy guard will have\n    \"_Untrusted_Guarded\" appended to the function name. Untrusted functions which don\u0027t have their\n    external calls wrapped in a reentrancy guard will have _Untrusted_Unguarded appended to their\n    name. One function has \"_Sometimes_Untrusted_Guarded\" appended to its name, as it\u0027s\n    _Untrusted_Guarded untrusted in some inheriting functions. This naming convention does not\n    apply to public and external functions.\n\n    An external function call is safe if (a) nothing after the function call depends on any\n    contract state that can change after the call is made, and (b) no contract state will be\n    changed after the external call. When those two conditions don\u0027t obviously hold we use a\n    reentrancy guard. When those two conditions do hold we safely ignore reentrancy protection.\n    We\u0027ll refer to calls that clearly meet both conditions as being \"Reentrancy Safe\" in other\n    comments.\n\n    You can prove to yourself that our code is reentrancy safe by verifying these things:\n    (1) Every function whose name ends with \"_Untrusted_Guarded\" has a reentrancy guard wrapped\n    around any external calls that it contains.\n    (2) Every function call whose name ends with \"_Untrusted_Unguarded\" is either Reentrancy Safe\n    as described above, or it\u0027s wrapped in a reentrancy guard.\n    (3) The body of every function whose name ends with \"_Untrusted_Unguarded\" contains only\n    Reentrancy Safe calls.\n    (4) Every external function in our contracts that modifies the state of a pre-existing\n    agreement is protected by a reentrancy check.\n\n    Note that a reentrancy guard looks like \"getThenSetPendingExternalCall(agreement, true)\"\n    before the code that it\u0027s guarding, and \"setPendingExternalCall(agreement, previousValue)\"\n    after the code that it\u0027s guarding. A reentrancy check looks like:\n    \u0027require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\u0027\n*/\n\ncontract AgreementManager is SafeUtils, EvidenceProducer {\n    // -------------------------------------------------------------------------------------------\n    // --------------------------------- special values ------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    // When the parties to an agreement report the outcome, they enter a \"resolution\", which is\n    // the amount of wei that party A should get. Party B is understood to get the remaining wei.\n    // RESOLUTION_NULL is a special value indicating \"no resolution has been entered yet\".\n    uint48 constant RESOLUTION_NULL = ~(uint48(0)); // set all bits to one.\n\n    uint constant MAX_DAYS_TO_RESPOND_TO_ARBITRATION_REQUEST = 365*30; // Approximately 30 years\n\n    // \"party A\" and \"party B\" are the two parties to the agreement\n    enum Party { A, B }\n\n    // ---------------------------------\n    // Offsets for AgreementData.boolValues\n    // --------------------------------\n    // We pack all of our bool values into a uint32 for gas cost optimization. Each constant below\n    // represents a \"virtual\" boolean variable.\n    // These are the offets into that uint32 (AgreementData.boolValues)\n\n    uint constant PARTY_A_STAKE_PAID = 0; // Has party A fully paid their stake?\n    uint constant PARTY_B_STAKE_PAID = 1; // Has party B fully paid their stake?\n    uint constant PARTY_A_REQUESTED_ARBITRATION = 2; // Has party A requested arbitration?\n    uint constant PARTY_B_REQUESTED_ARBITRATION = 3; // Has party B requested arbitration?\n    // The \"RECEIVED_DISTRIBUTION\" values represent whether we\u0027ve either sent an\n    // automatic funds distribution to the party, or they\u0027ve explicitly withdrawn.\n    // There\u0027s a non-intuitive edge case: these variables can be true even if the distribution\n    // amount is zero, as long as we went through the process that would have resulted in a\n    // positive distribution if there was one.\n    uint constant PARTY_A_RECEIVED_DISTRIBUTION = 4;\n    uint constant PARTY_B_RECEIVED_DISTRIBUTION = 5;\n    /** PARTY_A_RESOLVED_LAST is used to detect certain bad behavior where a party will first\n    resolve to a \"bad\" value, wait for their counterparty to summon an arbitrator, and then\n    resolve to the correct value to avoid having the arbitator rule against them. At any point\n    where the arbitrator has been paid before the dishonest party switches to a reasonable ruling,\n    we want the person who switched to the eventually official ruling last to be the one to pay\n    the arbitration fee.*/\n    uint constant PARTY_A_RESOLVED_LAST = 6;\n    uint constant ARBITRATOR_RESOLVED = 7; // Did the arbitrator enter a resolution?\n    uint constant ARBITRATOR_RECEIVED_DISPUTE_FEE = 8; // Did arbitrator receive the dispute fee?\n    // The DISPUTE_FEE_LIABILITY are used to keep track if which party is responsible for paying\n    // the arbitrator\u0027s dispute fee. If both are true then each party is responsible for half.\n    uint constant PARTY_A_DISPUTE_FEE_LIABILITY = 9;\n    uint constant PARTY_B_DISPUTE_FEE_LIABILITY = 10;\n    // We use this flag internally to guard against reentrancy attacks.\n    uint constant PENDING_EXTERNAL_CALL = 11;\n\n    // -------------------------------------------------------------------------------------------\n    // ------------------------------------- events ----------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    // Some events specific to inheriting contracts are only defined in those contracts, so this\n    // is not a full list of events that the instantiated contracts will output.\n\n    /// @notice links the agreementID to the hash of the agreement, so the written agreement terms\n    /// can be associated with this Ethereum contract.\n    event AgreementCreated(uint32 indexed agreementID, bytes32 agreementHash);\n\n    event PartyBDeposited(uint32 indexed agreementID);\n    event PartyAWithdrewEarly(uint32 indexed agreementID);\n    event PartyWithdrew(uint32 indexed agreementID);\n    event FundsDistributed(uint32 indexed agreementID);\n    event ArbitratorReceivedDisputeFee(uint32 indexed agreementID);\n    event ArbitrationRequested(uint32 indexed agreementID);\n    event DefaultJudgment(uint32 indexed agreementID);\n    event AutomaticResolution(uint32 indexed agreementID);\n\n    // -------------------------------------------------------------------------------------------\n    // --------------------------- public / external functions -----------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @notice A fallback function that prevents anyone from sending ETH directly to this\n    /// and inheriting contracts, since it isn\u0027t payable.\n    function () external {}\n\n    // -------------------------------------------------------------------------------------------\n    // ----------------------- internal getter and setter functions ------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @param flagField bitfield containing a bunch of virtual bool values\n    /// @param offset index into flagField of the bool we want to know the value of\n    /// @return value of the bool specified by offset\n    function getBool(uint flagField, uint offset) internal pure returns (bool) {\n        return ((flagField \u003e\u003e offset) \u0026 1) == 1;\n    }\n\n    /// @param flagField bitfield containing a bunch of virtual bool values\n    /// @param offset index into flagField of the bool we want to set the value of\n    /// @param value value to set the bit specified by offset to\n    /// @return the new value of flagField containing the modified bool value\n    function setBool(uint32 flagField, uint offset, bool value) internal pure returns (uint32) {\n        if (value) {\n            return flagField | uint32(1 \u003c\u003c offset);\n        } else {\n            return flagField \u0026 ~(uint32(1 \u003c\u003c offset));\n        }\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // -------------------------- internal helper functions --------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @notice Emit some events upon every contract creation\n    /// @param agreementHash hash of the text of the agreement\n    /// @param agreementURI URL of JSON representing the agreement\n    function emitAgreementCreationEvents(\n        uint agreementID,\n        bytes32 agreementHash,\n        string memory agreementURI\n    )\n        internal\n    {\n        // We want to emit both of these because we want to emit the agreement hash, and we also\n        // want to adhere to ERC1497\n        emit MetaEvidence(agreementID, agreementURI);\n        emit AgreementCreated(uint32(agreementID), agreementHash);\n    }\n}\n"},"AgreementManagerERC20.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./AgreementManager.sol\";\nimport \"./ERC20Interface.sol\";\n\n\n/**\n    @notice\n    See AgreementManager for comments on the overall nature of this contract.\n\n    This is the contract defining how ERC20 agreements work (in contrast to ETH-only).\n\n    @dev\n    The relevant part of the inheritance tree is:\n    AgreementManager\n        AgreementManagerERC20\n            AgreementManagerERC20_Simple\n            AgreementManagerERC20_ERC792\n\n    Search that file for \"NOTES ON REENTRANCY\" to learn more about our reentrancy protection\n    strategy.\n*/\n\ncontract AgreementManagerERC20 is AgreementManager {\n    // -------------------------------------------------------------------------------------------\n    // --------------------------------- special values ------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /**\n    We store ETH/token amounts internally uint48s. The amount that we store internally is\n    multipled by 10^TOKENPOWER, where TOKENPOWER is passed into the contract for each ERC20 token\n    that the contract needs to represent. The constant MAX_TOKEN_POWER is used to check that these\n    passed in values aren\u0027t too big. A token power of 50 can represent\n    2^48 * 10^50 ~= 2.8 * 10^64 (since 2^48 ~= 2.8 * 10^14) of a token\u0027s equivalent of wei.\n    There are 10^18 wei in an ETH, so if the token were ETH this could represent about\n    10^46 ETH. Note that 2^256 is about 10^77, so we\u0027re unable to represent extremely high\n    amounts of tokens with this scheme, but in practice we don\u0027t expect this to be an issue.\n    Using MAX_TOKEN_POWER keeps our exponentiation from overflowing, since even\n    if we add a bunch of 48 bit resolutions together before multiplying by 10^50 the result will\n    be far less than 10^77.*/\n    uint constant MAX_TOKEN_POWER = 50;\n\n    // -------------------------------------------------------------------------------------------\n    // ------------------------------------- events ----------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    event PartyResolved(\n        uint32 indexed agreementID,\n        uint resolutionTokenA,\n        uint resolutionTokenB\n    );\n\n    // -------------------------------------------------------------------------------------------\n    // -------------------------------- struct definitions ---------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /**\n    Whenever an agreement is created, we store its state in an AgreementDataERC20 object.\n    One of the main differences between this contract and AgreementManagerETH is the struct that\n    they use to store agreement data. This struct is much larger than the one needed for ETH only.\n    The variables are arranged so that the compiler can easily \"pack\" them into 7 uint256s\n    under the hood. Look at the comments for createAgreementA to see what all these\n    variables represent.\n    Each resolution has two components: TokenA and TokenB. This is because party A might be using\n    a different ERC20 token than party B. So we can\u0027t just treat units of party A\u0027s token the same\n    as units of party B\u0027s token.\n    TokenA is the token that A staked,\n    TokenB is the token that party B staked.\n    ArbitratorToken is the token that the arbitrator will be paid in.\n    ...all three tokens can be different.\n    Spacing shows the uint256s that we expect these to be packed in -- there are seven groups\n    separated by spaces, representing the seven uint256s that will be used internally.*/\n    struct AgreementDataERC20 {\n        // Some effort is made to group together variables that might be changed in the same\n        // transaction, for gas cost optimization.\n\n        uint48 partyAResolutionTokenA; // Party A\u0027s resolution for tokenA\n        uint48 partyAResolutionTokenB; // Party A\u0027s resolution for tokenB\n        uint48 partyBResolutionTokenA; // Party B\u0027s resolution for tokenA\n        uint48 partyBResolutionTokenB; // Party B\u0027s resolution for tokenB\n        /** nextArbitrationStepAllowedAfterTimestamp is the most complex state variable, as we\n        want to keep the contract small to save gas cost. Initially it represents the timestamp\n        after which the parties are allowed to request arbitration. Once arbitration is requested\n        the first time, it represents how long the party who hasn\u0027t yet requested arbitration (or\n        fully paid for arbitration in the case of ERC 792 arbitration) has until they lose via a\n        \"default judgment\" (aka lose the dispute simply because they didn\u0027t post the arbitration\n        fee) */\n        uint32 nextArbitrationStepAllowedAfterTimestamp;\n        // A bitmap that holds all of our \"virtual\" bool values.\n        // See the offsets for bool values defined above for a list of the boolean info we store.\n        uint32 boolValues;\n\n        address partyAToken; // Address of the token contract that party A stakes (or 0x0 if ETH)\n        // resolutionTokenA and resolutionTokenB hold the \"official, final\" resolution of the\n        // agreement. Once these values have been set, it means the agreement is over and funds\n        // can be withdrawn / distributed.\n        uint48 resolutionTokenA;\n        uint48 resolutionTokenB;\n\n        address partyBToken; // Address of the token contract that party A stakes (or 0x0 if ETH)\n        // An agreement can be created with an optional \"automatic\" resolution, which either party\n        // can trigger after autoResolveAfterTimestamp.\n        uint48 automaticResolutionTokenA;\n        uint48 automaticResolutionTokenB;\n\n        // Address of the token contract that the arbitrator is paid in (or 0x0 if ETH)\n        address arbitratorToken;\n        // To understand the following three variables, see the comments above the definition of\n        // MAX_TOKEN_POWER\n        uint8 partyATokenPower;\n        uint8 partyBTokenPower;\n        uint8 arbitratorTokenPower;\n\n        address partyAAddress; // ETH address of party A\n        uint48 partyAStakeAmount; // Amount that party A is required to stake\n        // An optional arbitration fee that is sent to the arbitrator\u0027s address once both parties\n        // have deposited their stakes.\n        uint48 partyAInitialArbitratorFee;\n\n        address partyBAddress; // ETH address of party B\n        uint48 partyBStakeAmount; // Amount that party B is required to stake\n        // An optional arbitration fee that is sent to the arbitrator\u0027s address once both parties\n        // have deposited their stakes.\n        uint48 partyBInitialArbitratorFee;\n\n        address arbitratorAddress; // ETH address of Arbitrator\n        uint48 disputeFee; // Fee paid to arbitrator only if there\u0027s a dispute and they do work.\n        // The timestamp after which either party can trigger the \"automatic resolution\".\n        // This can only be triggered if no one has requested arbitration.\n        uint32 autoResolveAfterTimestamp;\n       // The # of days that the other party has to respond to an arbitration request from the\n        // other party. If they fail to respond in time, the other party can trigger a default\n        // judgment.\n        uint16 daysToRespondToArbitrationRequest;\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // --------------------------------- internal state ------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    // We store our agreements in a single array. When a new agreement is created we add it to the\n    // end. The index into this array is the agreementID.\n    // Agreements not having ERC792 disputes will only use an element in the agreements array for\n    // their state.\n    AgreementDataERC20[] agreements;\n\n    // -------------------------------------------------------------------------------------------\n    // ---------------------------- external getter functions ------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    function getResolutionNull() external pure returns (uint, uint) {\n        return (resolutionToWei(RESOLUTION_NULL, 0), resolutionToWei(RESOLUTION_NULL, 0));\n    }\n    function getNumberOfAgreements() external view returns (uint) {\n        return agreements.length;\n    }\n\n    /// @return the full internal state of an agreement.\n    function getState(\n        uint agreementID\n    )\n        external\n        view\n        returns (address[6] memory, uint[23] memory, bool[12] memory, bytes memory);\n\n    // -------------------------------------------------------------------------------------------\n    // -------------------- main external functions that affect state ----------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /**\n    @notice Adds a new agreement to the agreements array.\n    This is only callable by partyA. So the caller needs to rearrange addresses so that they\u0027re\n    partyA. Party A needs to pay their stake as part of calling this function (either sending ETH,\n    or having approved a pull from the neccessary ERC20 tokens).\n    @dev createAgreementA differs between versions, so is defined low in the inheritance tree.\n    We don\u0027t need re-entrancy protection here because createAgreementA can\u0027t influence\n    existing agreeemnts.\n    @param agreementHash hash of agreement details. Not stored, just emitted in an event.\n    @param agreementURI URI to \u0027metaEvidence\u0027 as defined in ERC 1497\n    @param addresses :\n    addresses[0]: address of partyA\n    addresses[1]: address of partyB\n    addresses[2]: address of arbitrator\n    addresses[3]: token that partyA is depositing.. 0 if ETH\n    addresses[4]: token that partyB is depositing.. 0 if ETH\n    addresses[5]: token that arbitrator is paid in.. 0 if ETH\n    @param quantities :\n    quantities[0]: amount that party A is staking\n    quantities[1]: amount that party B is staking\n    quantities[2]: amount that party A pays arbitrator regardless of whether there\u0027s a dispute\n    quantities[3]: amount that party B pays arbitrator regardless of whether there\u0027s a dispute\n    quantities[4]: disputeFee: 48 bit value expressing in units of 10^^arbitratorTokenPower\n    quantities[5]: Amount of wei from party A\u0027s stake to go to party A if an automatic resolution\n                   is triggered.\n    quantities[6]: Amount of wei from party B\u0027s stake to go to party A if an automatic resolution\n                   is triggered.\n    quantities[7]: 16 bit value, # of days to respond to arbitration request\n    quantities[8]: 32 bit timestamp value before which arbitration can\u0027t be requested.\n    quantities[9]: 32 bit timestamp value after which auto-resolution is allowed if no one\n                   requested arbitration. 0 means never.\n    quantities[10]: value such that all amounts of party A\u0027s staked token type are internally in\n                    units of 10^^value\n    quantities[11]: value such that all amounts of party B\u0027s staked token type are internally in\n                    units of 10^^value\n    quantities[12]: value such that all amounts of arbitrator\u0027s preferred token type are\n                    internally in units of 10^^value\n    @param arbExtraData Data to pass in to ERC792 arbitrator if a dispute is ever created. Use\n    null when creating non-ERC792 agreements\n    @return the agreement id of the newly added agreement*/\n    function createAgreementA(\n        bytes32 agreementHash,\n        string calldata agreementURI,\n        address[6] calldata addresses,\n        uint[13] calldata quantities,\n        bytes calldata arbExtraData\n    )\n        external\n        payable\n        returns (uint)\n    {\n        require(msg.sender == addresses[0], \"Only party A can call createAgreementA.\");\n        require(\n            (\n                quantities[10] \u003c= MAX_TOKEN_POWER \u0026\u0026\n                quantities[11] \u003c= MAX_TOKEN_POWER \u0026\u0026\n                quantities[12] \u003c= MAX_TOKEN_POWER\n            ),\n            \"Token power too large.\"\n        );\n        require(\n            (\n                addresses[0] != addresses[1] \u0026\u0026\n                addresses[0] != addresses[2] \u0026\u0026\n                addresses[1] != addresses[2]\n            ),\n            \"partyA, partyB, and arbitrator addresses must be unique.\"\n        );\n        require(\n            quantities[7] \u003e= 1 \u0026\u0026 quantities[7] \u003c= MAX_DAYS_TO_RESPOND_TO_ARBITRATION_REQUEST,\n            \"Days to respond to arbitration was out of range.\"\n        );\n\n        // Populate a AgreementDataERC20 struct with the info provided.\n        AgreementDataERC20 memory agreement;\n        agreement.partyAAddress = addresses[0];\n        agreement.partyBAddress = addresses[1];\n        agreement.arbitratorAddress = addresses[2];\n        agreement.partyAToken = addresses[3];\n        agreement.partyBToken = addresses[4];\n        agreement.arbitratorToken = addresses[5];\n        agreement.partyAResolutionTokenA = RESOLUTION_NULL;\n        agreement.partyAResolutionTokenB = RESOLUTION_NULL;\n        agreement.partyBResolutionTokenA = RESOLUTION_NULL;\n        agreement.partyBResolutionTokenB = RESOLUTION_NULL;\n        agreement.resolutionTokenA = RESOLUTION_NULL;\n        agreement.resolutionTokenB = RESOLUTION_NULL;\n        agreement.partyAStakeAmount = toLargerUnit(quantities[0], quantities[10]);\n        agreement.partyBStakeAmount = toLargerUnit(quantities[1], quantities[11]);\n        require(\n            (\n                agreement.partyAStakeAmount \u003c RESOLUTION_NULL \u0026\u0026\n                agreement.partyBStakeAmount \u003c RESOLUTION_NULL\n            ),\n            \"Stake amounts were too large. Consider increasing the token powers.\"\n        );\n        agreement.partyAInitialArbitratorFee = toLargerUnit(quantities[2], quantities[12]);\n        agreement.partyBInitialArbitratorFee = toLargerUnit(quantities[3], quantities[12]);\n        agreement.disputeFee = toLargerUnit(quantities[4], quantities[12]);\n        agreement.automaticResolutionTokenA = toLargerUnit(quantities[5], quantities[10]);\n        agreement.automaticResolutionTokenB = toLargerUnit(quantities[6], quantities[11]);\n        require(\n            (\n                agreement.automaticResolutionTokenA \u003c= agreement.partyAStakeAmount \u0026\u0026\n                agreement.automaticResolutionTokenB \u003c= agreement.partyBStakeAmount\n            ),\n            \"Automatic resolution was too large.\"\n        );\n        agreement.daysToRespondToArbitrationRequest = toUint16(quantities[7]);\n        agreement.nextArbitrationStepAllowedAfterTimestamp = toUint32(quantities[8]);\n        agreement.autoResolveAfterTimestamp = toUint32(quantities[9]);\n        agreement.partyATokenPower = toUint8(quantities[10]);\n        agreement.partyBTokenPower = toUint8(quantities[11]);\n        agreement.arbitratorTokenPower = toUint8(quantities[12]);\n        // set boolean values\n        uint32 tempBools = setBool(0, PARTY_A_STAKE_PAID, true);\n        if (add(quantities[1], quantities[3]) == 0) {\n            tempBools = setBool(tempBools, PARTY_B_STAKE_PAID, true);\n        }\n        agreement.boolValues = tempBools;\n\n        uint agreementID = sub(agreements.push(agreement), 1);\n\n        checkContractSpecificConditionsForCreation(agreement.arbitratorToken);\n\n        // This is a function because we want it to be a no-op for non-ERC792 agreements.\n        storeArbitrationExtraData(agreementID, arbExtraData);\n\n        emitAgreementCreationEvents(agreementID, agreementHash, agreementURI);\n\n        // Verify that partyA paid deposit and fees.\n        verifyDeposit_Untrusted_Guarded(agreements[agreementID], Party.A);\n\n        // Pay the arbiter if needed, which happens if B was staking no funds and needed no\n        // initial fee, but there was an initial fee from A.\n        if ((add(quantities[1], quantities[3]) == 0) \u0026\u0026 (quantities[2] \u003e 0)) {\n            payOutInitialArbitratorFee_Untrusted_Unguarded(agreements[agreementID]);\n        }\n\n        return agreementID;\n    }\n\n    /// @notice Called by PartyB to deposit their stake, locking in the agreement so no one can\n    /// unilaterally withdraw. PartyA already deposited funds in createAgreementA, so we only need\n    /// a deposit function for partyB.\n    function depositB(uint agreementID) external payable {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on.\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(msg.sender == agreement.partyBAddress, \"Function can only be called by party B.\");\n        require(!partyStakePaid(agreement, Party.B), \"Party B already deposited their stake.\");\n        // No need to check that party A deposited: they can\u0027t create an agreement otherwise.\n\n        setPartyStakePaid(agreement, Party.B, true);\n\n        emit PartyBDeposited(uint32(agreementID));\n\n        verifyDeposit_Untrusted_Guarded(agreement, Party.B);\n\n        if (add(agreement.partyAInitialArbitratorFee, agreement.partyBInitialArbitratorFee) \u003e 0) {\n            payOutInitialArbitratorFee_Untrusted_Unguarded(agreement);\n        }\n    }\n\n    /// @notice Called to report a resolution of the agreement by a party. The resolution\n    /// specifies how funds should be distributed between the parties.\n    /// @param resTokenA Amount of party A\u0027s stake that the caller thinks should go to party A.\n    /// The remaining amount would go to party B.\n    /// @param resTokenB Amount of party B\u0027s stake that the caller thinks should go to party A.\n    /// The remaining amount would go to party B.\n    /// @param distributeFunds Whether to distribute funds to the two parties if this call\n    /// results in an official resolution to the agreement.\n    function resolveAsParty(\n        uint agreementID,\n        uint resTokenA,\n        uint resTokenB,\n        bool distributeFunds\n    )\n        external\n    {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on.\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(agreementIsLockedIn(agreement), \"Agreement not locked in.\");\n\n        uint48 resA = toLargerUnit(resTokenA, agreement.partyATokenPower);\n        uint48 resB = toLargerUnit(resTokenB, agreement.partyBTokenPower);\n        require(resA \u003c= agreement.partyAStakeAmount, \"Resolution out of range for token A.\");\n        require(resB \u003c= agreement.partyBStakeAmount, \"Resolution out of range for token B.\");\n\n        (Party callingParty, Party otherParty) = getCallingPartyAndOtherParty(agreement);\n\n        // Keep track of who was the last to resolve.. useful for punishing \u0027late\u0027 resolutions.\n        // We check the existing state of partyAResolvedLast only as a perf optimization, to avoid\n        // unnecessary writes.\n        if (callingParty == Party.A \u0026\u0026 !partyAResolvedLast(agreement)) {\n            setPartyAResolvedLast(agreement, true);\n        } else if (callingParty == Party.B \u0026\u0026 partyAResolvedLast(agreement)) {\n            setPartyAResolvedLast(agreement, false);\n        }\n\n        // See if we need to update the deadline to respond to arbitration. We want to avoid a\n        // situation where someone has (or will soon have) the right to request a default\n        // judgment, then they change their resolution to be more favorable to them and\n        // immediately request a default judgment for the new resolution.\n        if (partyIsCloserToWinningDefaultJudgment(agreementID, agreement, callingParty)) {\n            // If new resolution isn\u0027t compatible with the existing one, then the caller possibly\n            // made the resolution more favorable to themself.\n            // We know that an old resolution exists because for the caller to be closer to\n            // winning a default judgment they must have requested arbitration, and they can only\n            // request arbitration after resolving.\n            (uint oldResA, uint oldResB) = partyResolution(agreement, callingParty);\n            if (\n                !resolutionsAreCompatibleBothExist(\n                    agreement,\n                    resA,\n                    resB,\n                    oldResA,\n                    oldResB,\n                    callingParty\n                )\n            ) {\n                updateArbitrationResponseDeadline(agreement);\n            }\n        }\n\n        setPartyResolution(agreement, callingParty, resA, resB);\n\n        emit PartyResolved(uint32(agreementID), resA, resB);\n\n        // If the resolution is \u0027compatible\u0027 with that of the other person, make it the\n        // final resolution.\n        (uint otherResA, uint otherResB) = partyResolution(agreement, otherParty);\n        if (\n            resolutionsAreCompatible(\n                agreement,\n                resA,\n                resB,\n                otherResA,\n                otherResB,\n                callingParty\n            )\n        ) {\n            finalizeResolution_Untrusted_Unguarded(\n                agreementID,\n                agreement,\n                resA,\n                resB,\n                distributeFunds,\n                false\n            );\n        }\n    }\n\n    /// @notice If A calls createAgreementA but B is delaying in calling depositB, A can get their\n    /// funds back by calling earlyWithdrawA. This closes the agreement to further deposits. A or\n    /// B wouldhave to call createAgreementA again if they still wanted to do an agreement.\n    function earlyWithdrawA(uint agreementID) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(msg.sender == agreement.partyAAddress, \"earlyWithdrawA not called by party A.\");\n        require(\n            partyStakePaid(agreement, Party.A) \u0026\u0026 !partyStakePaid(agreement, Party.B),\n            \"Early withdraw not allowed.\"\n        );\n        require(!partyReceivedDistribution(agreement, Party.A), \"partyA already received funds.\");\n\n        setPartyReceivedDistribution(agreement, Party.A, true);\n\n        emit PartyAWithdrewEarly(uint32(agreementID));\n\n        executeDistribution_Untrusted_Unguarded(\n            agreement.partyAAddress,\n            agreement.partyAToken,\n            toWei(agreement.partyAStakeAmount, agreement.partyATokenPower),\n            agreement.arbitratorToken,\n            toWei(agreement.partyAInitialArbitratorFee, agreement.arbitratorTokenPower)\n        );\n    }\n\n    /// @notice This can only be called after a resolution is established.\n    /// Each party calls this to withdraw the funds they\u0027re entitled to, based on the resolution.\n    /// Normally funds are distributed automatically when the agreement gets resolved. However\n    /// it is possible for a malicious user to prevent their counterparty from getting an\n    /// automatic distribution, by using an address for the agreement that can\u0027t receive payments.\n    /// If this happens, the agreement should be resolved by setting the distributeFunds parameter\n    /// to false in whichever function is called to resolve the disagreement. Then the parties can\n    /// independently extract their funds via this function.\n    function withdraw(uint agreementID) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\n        require(agreement.resolutionTokenA != RESOLUTION_NULL, \"Agreement not resolved.\");\n\n        emit PartyWithdrew(uint32(agreementID));\n\n        distributeFundsToPartyHelper_Untrusted_Unguarded(\n            agreementID,\n            agreement,\n            getCallingParty(agreement)\n        );\n    }\n\n    /// @notice Request that the arbitrator get involved to settle the disagreement.\n    /// Each party needs to pay the full arbitration fee when calling this. However they will be\n    /// refunded the full fee if the arbitrator agrees with them.\n    function requestArbitration(uint agreementID) external payable;\n\n    /// @notice If the other person hasn\u0027t paid their arbitration fee in time, this function\n    /// allows the caller to cause the agreement to be resolved in their favor without the\n    /// arbitrator getting involved.\n    /// @param distributeFunds Whether to distribute funds to both parties.\n    function requestDefaultJudgment(uint agreementID, bool distributeFunds) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on.\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(agreementIsLockedIn(agreement), \"Agreement not locked in.\");\n\n        (Party callingParty, Party otherParty) = getCallingPartyAndOtherParty(agreement);\n\n        require(\n            !partyResolutionIsNull(agreement, callingParty),\n            \"requestDefaultJudgment called before party resolved.\"\n        );\n        require(\n            block.timestamp \u003e agreement.nextArbitrationStepAllowedAfterTimestamp,\n            \"requestDefaultJudgment not allowed yet.\"\n        );\n\n        emit DefaultJudgment(uint32(agreementID));\n\n        require(\n            partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\n                agreementID,\n                agreement,\n                callingParty\n            ),\n            \"Party didn\u0027t fully pay the dispute fee.\"\n        );\n        require(\n            !partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\n                agreementID,\n                agreement,\n                otherParty\n            ),\n            \"Other party fully paid the dispute fee.\"\n        );\n\n        (uint48 partyResA, uint48 partyResB) = partyResolution(\n            agreement,\n            callingParty\n        );\n\n        finalizeResolution_Untrusted_Unguarded(\n            agreementID,\n            agreement,\n            partyResA,\n            partyResB,\n            distributeFunds,\n            false\n        );\n    }\n\n    /// @notice If enough time has elapsed, either party can trigger auto-resolution (if enabled)\n    /// by calling this function, provided that neither party has requested arbitration yet.\n    /// @param distributeFunds Whether to distribute funds to both parties\n    function requestAutomaticResolution(uint agreementID, bool distributeFunds) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on.\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(agreementIsLockedIn(agreement), \"Agreement not locked in.\");\n        require(\n            (\n                !partyRequestedArbitration(agreement, Party.A) \u0026\u0026\n                !partyRequestedArbitration(agreement, Party.B)\n            ),\n            \"Arbitration stops auto-resolution\"\n        );\n        require(\n            msg.sender == agreement.partyAAddress || msg.sender == agreement.partyBAddress,\n            \"Unauthorized sender.\"\n        );\n        require(\n            agreement.autoResolveAfterTimestamp \u003e 0,\n            \"Agreement does not support automatic resolutions.\"\n        );\n        require(\n            block.timestamp \u003e agreement.autoResolveAfterTimestamp,\n            \"AutoResolution not allowed yet.\"\n        );\n\n        emit AutomaticResolution(uint32(agreementID));\n\n        finalizeResolution_Untrusted_Unguarded(\n            agreementID,\n            agreement,\n            agreement.automaticResolutionTokenA,\n            agreement.automaticResolutionTokenB,\n            distributeFunds,\n            false\n        );\n    }\n\n    /// @notice Either party can record evidence on the blockchain in case off-chain communication\n    /// breaks down. Uses ERC1497. Allows submitting evidence even after an agreement is closed in\n    /// case someone wants to clear their name.\n    /// @param evidence can be any string containing evidence. Usually will be a URI to a document\n    /// or video containing evidence.\n    function submitEvidence(uint agreementID, string calldata evidence) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(\n            (\n                msg.sender == agreement.partyAAddress ||\n                msg.sender == agreement.partyBAddress ||\n                msg.sender == agreement.arbitratorAddress\n            ),\n            \"Unauthorized sender.\"\n        );\n\n        emit Evidence(Arbitrator(agreement.arbitratorAddress), agreementID, msg.sender, evidence);\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // ----------------------- internal getter and setter functions ------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    // Functions that simulate direct access to AgreementDataERC20 state variables.\n    // These are used either for bools (where we need to use a bitmask), or for\n    // functions when we need to vary between party A/B depending on the argument.\n    // The later is necessary because the solidity compiler can\u0027t pack structs well when their\n    // elements are arrays. So we can\u0027t just index into an array.\n\n    // ------------- Some getter functions ---------------\n\n    function partyResolution(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint48, uint48)\n    {\n        if (party == Party.A)\n            return (agreement.partyAResolutionTokenA, agreement.partyAResolutionTokenB);\n        else\n            return (agreement.partyBResolutionTokenA, agreement.partyBResolutionTokenB);\n    }\n\n    function partyResolutionIsNull(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (bool)\n    {\n         // We can test only token A, because if token A will be null IFF token B is null\n        if (party == Party.A) return agreement.partyAResolutionTokenA == RESOLUTION_NULL;\n        else return agreement.partyBResolutionTokenA == RESOLUTION_NULL;\n    }\n\n    function partyAddress(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (address)\n    {\n        if (party == Party.A) return agreement.partyAAddress;\n        else return agreement.partyBAddress;\n    }\n\n    function partyStakePaid(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_STAKE_PAID);\n        else return getBool(agreement.boolValues, PARTY_B_STAKE_PAID);\n    }\n\n    function partyStakeAmount(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint48)\n    {\n        if (party == Party.A) return agreement.partyAStakeAmount;\n        else return agreement.partyBStakeAmount;\n    }\n\n    function partyInitialArbitratorFee(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint48)\n    {\n        if (party == Party.A) return agreement.partyAInitialArbitratorFee;\n        else return agreement.partyBInitialArbitratorFee;\n    }\n\n    function partyRequestedArbitration(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_REQUESTED_ARBITRATION);\n        else return getBool(agreement.boolValues, PARTY_B_REQUESTED_ARBITRATION);\n    }\n\n    function partyReceivedDistribution(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_RECEIVED_DISTRIBUTION);\n        else return getBool(agreement.boolValues, PARTY_B_RECEIVED_DISTRIBUTION);\n    }\n\n    function partyToken(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (address)\n    {\n        if (party == Party.A) return agreement.partyAToken;\n        else return agreement.partyBToken;\n    }\n\n    function partyTokenPower(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint8)\n    {\n        if (party == Party.A) return agreement.partyATokenPower;\n        else return agreement.partyBTokenPower;\n    }\n\n    function partyAResolvedLast(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return getBool(agreement.boolValues, PARTY_A_RESOLVED_LAST);\n    }\n\n    function arbitratorResolved(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return getBool(agreement.boolValues, ARBITRATOR_RESOLVED);\n    }\n\n    function arbitratorReceivedDisputeFee(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return getBool(agreement.boolValues, ARBITRATOR_RECEIVED_DISPUTE_FEE);\n    }\n\n    function partyDisputeFeeLiability(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (bool)\n    {\n        if (party == Party.A) return getBool(agreement.boolValues, PARTY_A_DISPUTE_FEE_LIABILITY);\n        else return getBool(agreement.boolValues, PARTY_B_DISPUTE_FEE_LIABILITY);\n    }\n\n    function pendingExternalCall(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return getBool(agreement.boolValues, PENDING_EXTERNAL_CALL);\n    }\n\n    // ------------- Some setter functions ---------------\n\n    function setPartyResolution(\n        AgreementDataERC20 storage agreement,\n        Party party,\n        uint48 valueTokenA,\n        uint48 valueTokenB\n    )\n        internal\n    {\n        if (party == Party.A) {\n            agreement.partyAResolutionTokenA = valueTokenA;\n            agreement.partyAResolutionTokenB = valueTokenB;\n        } else {\n            agreement.partyBResolutionTokenA = valueTokenA;\n            agreement.partyBResolutionTokenB = valueTokenB;\n        }\n    }\n\n    function setPartyStakePaid(\n        AgreementDataERC20 storage agreement,\n        Party party,\n        bool value\n    )\n        internal\n    {\n        if (party == Party.A)\n            agreement.boolValues = setBool(agreement.boolValues, PARTY_A_STAKE_PAID, value);\n        else\n            agreement.boolValues = setBool(agreement.boolValues, PARTY_B_STAKE_PAID, value);\n    }\n\n    function setPartyRequestedArbitration(\n        AgreementDataERC20 storage agreement,\n        Party party,\n        bool value\n    )\n        internal\n    {\n        if (party == Party.A) {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_A_REQUESTED_ARBITRATION,\n                value\n            );\n        } else {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_B_REQUESTED_ARBITRATION,\n                value\n            );\n        }\n    }\n\n    function setPartyReceivedDistribution(\n        AgreementDataERC20 storage agreement,\n        Party party,\n        bool value\n    )\n        internal\n    {\n        if (party == Party.A) {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_A_RECEIVED_DISTRIBUTION,\n                value\n            );\n        } else {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_B_RECEIVED_DISTRIBUTION,\n                value\n            );\n        }\n    }\n\n    function setPartyAResolvedLast(AgreementDataERC20 storage agreement, bool value) internal {\n        agreement.boolValues = setBool(agreement.boolValues, PARTY_A_RESOLVED_LAST, value);\n    }\n\n    function setArbitratorResolved(AgreementDataERC20 storage agreement, bool value) internal {\n        agreement.boolValues = setBool(agreement.boolValues, ARBITRATOR_RESOLVED, value);\n    }\n\n    function setArbitratorReceivedDisputeFee(\n        AgreementDataERC20 storage agreement,\n        bool value\n    )\n        internal\n    {\n        agreement.boolValues = setBool(\n            agreement.boolValues,\n            ARBITRATOR_RECEIVED_DISPUTE_FEE,\n            value\n        );\n    }\n\n    function setPartyDisputeFeeLiability(\n        AgreementDataERC20 storage agreement,\n        Party party,\n        bool value\n    )\n        internal\n    {\n        if (party == Party.A) {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_A_DISPUTE_FEE_LIABILITY,\n                value\n            );\n        } else {\n            agreement.boolValues = setBool(\n                agreement.boolValues,\n                PARTY_B_DISPUTE_FEE_LIABILITY,\n                value\n            );\n        }\n    }\n\n    function setPendingExternalCall(AgreementDataERC20 storage agreement, bool value) internal {\n        agreement.boolValues = setBool(agreement.boolValues, PENDING_EXTERNAL_CALL, value);\n    }\n\n    /// @notice set the value of PENDING_EXTERNAL_CALL and return the previous value.\n    function getThenSetPendingExternalCall(\n        AgreementDataERC20 storage agreement,\n        bool value\n    )\n        internal\n        returns (bool)\n    {\n        uint32 previousBools = agreement.boolValues;\n        agreement.boolValues = setBool(previousBools, PENDING_EXTERNAL_CALL, value);\n        return getBool(previousBools, PENDING_EXTERNAL_CALL);\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // -------------------------- internal helper functions --------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @notice We store ETH/token amounts in uint48s demoninated in larger units of that token.\n    /// Specifically, our internal representation is in units of 10^tokenPower wei.\n    /// toWei converts from our internal representation to the wei amount.\n    /// @dev This can\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\n    /// @param value internal value that we want to convert to wei\n    /// @param tokenPower The exponent to use to convert our internal representation to wei.\n    /// @return the wei value\n    function toWei(uint value, uint tokenPower) internal pure returns (uint) {\n        return mul(value, (10 ** tokenPower));\n    }\n\n    /// @notice Like toWei but resolutionToWei is for \"resolution\" values which might have a\n    /// special value of RESOLUTION_NULL, which we need to handle separately.\n    /// @dev This can\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\n    /// @param value internal value that we want to convert to wei\n    /// @param tokenPower The exponent to use to convert our internal representation to wei.\n    /// @return the wei value\n    function resolutionToWei(uint value, uint tokenPower) internal pure returns (uint) {\n        if (value == RESOLUTION_NULL) {\n            return uint(~0); // set all bits of a uint to 1\n        }\n        return mul(value, (10 ** tokenPower));\n    }\n\n    /// @notice Convert a value expressed in wei to our internal representation (which is\n    /// in units of 10^tokenPower wei)\n    /// @dev This can\u0027t overflow. For an explanation of why see the comments for MAX_TOKEN_POWER.\n    /// @param weiValue wei value that we want to convert from\n    /// @param tokenPower The exponent to use to convert wei to our internal representation\n    /// @return the amount of our internal units of the given value\n    function toLargerUnit(uint weiValue, uint tokenPower) internal pure returns (uint48) {\n        return toUint48(weiValue / (10 ** tokenPower));\n    }\n\n    /// @notice Requires that the caller be party A or party B.\n    /// @return whichever party the caller is.\n    function getCallingParty(AgreementDataERC20 storage agreement) internal view returns (Party) {\n        if (msg.sender == agreement.partyAAddress) {\n            return Party.A;\n        } else if (msg.sender == agreement.partyBAddress) {\n            return Party.B;\n        } else {\n            require(false, \"getCallingParty must be called by a party to the agreement.\");\n        }\n    }\n\n    /// @param party a party for whom we want to get the other party.\n    /// @return the other party who was not given in the parameter.\n    function getOtherParty(Party party) internal pure returns (Party) {\n        if (party == Party.A) {\n            return Party.B;\n        }\n        return Party.A;\n    }\n\n    /// @notice Fails if called by anyone other than a party.\n    /// @return the calling party first and the \"other party\" second.\n    function getCallingPartyAndOtherParty(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (Party, Party)\n    {\n        if (msg.sender == agreement.partyAAddress) {\n            return (Party.A, Party.B);\n        } else if (msg.sender == agreement.partyBAddress) {\n            return (Party.B, Party.A);\n        } else {\n            require(\n                false,\n                \"getCallingPartyAndOtherParty must be called by a party to the agreement.\"\n            );\n        }\n    }\n\n    /// @notice This is a version of resolutionsAreCompatible where we know that both resolutions\n    /// are not RESOLUTION_NULL. It\u0027s more gas efficient so we should use it when possible.\n    /// See comments for resolutionsAreCompatible to understand the purpose and arguments.\n    function resolutionsAreCompatibleBothExist(\n        AgreementDataERC20 storage agreement,\n        uint resolutionTokenA,\n        uint resolutionTokenB,\n        uint otherResolutionTokenA,\n        uint otherResolutionTokenB,\n        Party resolutionParty\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // If the tokens are different, ensure that both token resolutions are compatible.\n        if (agreement.partyAToken != agreement.partyBToken) {\n            if (resolutionParty == Party.A) {\n                return resolutionTokenA \u003c= otherResolutionTokenA \u0026\u0026\n                    resolutionTokenB \u003c= otherResolutionTokenB;\n            } else {\n                return otherResolutionTokenA \u003c= resolutionTokenA \u0026\u0026\n                    otherResolutionTokenB \u003c= resolutionTokenB;\n            }\n        }\n\n        // Now we know tokens are the same. We need to convert to wei because the same resolution\n        // can be represented in many different ways.\n        uint resSum = add(\n            resolutionToWei(resolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(resolutionTokenB, agreement.partyBTokenPower)\n        );\n        uint otherSum = add(\n            resolutionToWei(otherResolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(otherResolutionTokenB, agreement.partyBTokenPower)\n        );\n        if (resolutionParty == Party.A) {\n            return resSum \u003c= otherSum;\n        } else {\n            return otherSum \u003c= resSum;\n        }\n    }\n\n    /// @notice Compatible means that the participants don\u0027t disagree in a selfish direction.\n    /// Alternatively, it means that we know some resolution will satisfy both parties.\n    /// If one person resolves to give the other person the maximum possible amount, this is\n    /// always compatible with the other person\u0027s resolution, even if that resolution is\n    /// RESOLUTION_NULL. Otherwise, one person having a resolution of RESOLUTION_NULL\n    /// implies the resolutions are not compatible.\n    /// @param resolutionTokenA The component of a resolution provided by either party A\n    /// or party B representing party A\u0027s staked token. Can\u0027t be RESOLUTION_NULL.\n    /// @param resolutionTokenB The component of a resolution provided by either party A\n    /// or party B representing party B\u0027s staked token. Can\u0027t be RESOLUTION_NULL.\n    /// @param otherResolutionTokenA The component of a resolution provided either by the\n    /// other party or by the arbitrator representing party A\u0027s staked token. It may be\n    /// RESOLUTION_NULL.\n    /// @param otherResolutionTokenB The component of a resolution provided either by the\n    /// other party or by the arbitrator representing party A\u0027s staked token. It may be\n    /// RESOLUTION_NULL.\n    /// @param resolutionParty The party corresponding to the resolution provided by the\n    /// \u0027resolutionTokenA\u0027 and \u0027resolutionTokenB\u0027 parameters.\n    /// @return whether the resolutions are compatible.\n    function resolutionsAreCompatible(\n        AgreementDataERC20 storage agreement,\n        uint resolutionTokenA,\n        uint resolutionTokenB,\n        uint otherResolutionTokenA,\n        uint otherResolutionTokenB,\n        Party resolutionParty\n    )\n        internal\n        view\n        returns (bool)\n    {\n        // If we\u0027re not dealing with the NULL case, we can use resolutionsAreCompatibleBothExist\n        if (otherResolutionTokenA != RESOLUTION_NULL) {\n            return resolutionsAreCompatibleBothExist(\n                agreement,\n                resolutionTokenA,\n                resolutionTokenB,\n                otherResolutionTokenA,\n                otherResolutionTokenB,\n                resolutionParty\n            );\n        }\n\n        // Now we know otherResolution is null.\n        // See if resolutionParty wants to give all funds to the other party.\n        if (resolutionParty == Party.A) {\n            // only 0 from Party A is compatible with RESOLUTION_NULL\n            return resolutionTokenA == 0 \u0026\u0026 resolutionTokenB == 0;\n        } else {\n            // only the max possible amount from Party B is compatible with RESOLUTION_NULL\n            return resolutionTokenA == agreement.partyAStakeAmount \u0026\u0026\n                resolutionTokenB == agreement.partyBStakeAmount;\n        }\n    }\n\n    /// @return Whether the party provided is closer to winning a default judgment than the other\n    /// party.\n    function partyIsCloserToWinningDefaultJudgment(\n        uint agreementID,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        returns (bool);\n\n    /**\n    @notice When a party withdraws, they may be owed a refund for any arbitration fee that they\u0027ve\n    paid in because this contract requires the loser of arbitration to pay the full fee.\n    But since we don\u0027t know who the loser will be ahead of time, both parties must pay in the\n    full arbitration amount when requesting arbitration.\n    We assume we\u0027re only calling this function from an agreement with an official resolution.\n    If this function has a it has a bug that overestimates the total amount that partyA and partyB\n    can withdraw it could cause funds to be drained from the contract. Therefore\n    it will be commented extensively in the implementations by inheriting contracts.\n    @param agreementID id of the agreement\n    @param agreement the agreement struct\n    @param party the party for whom we are calculating the refund\n    @return the value of the refund in wei.*/\n    function getPartyArbitrationRefundInWei(\n        uint agreementID,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint);\n\n    /// @notice This lets us write one version of createAgreementA for both ERC792 and simple\n    /// arbitration.\n    /// @param arbExtraData some data that the creator of the agreement optionally passes in\n    /// when creating an ERC792 agreement.\n    function storeArbitrationExtraData(uint agreementID, bytes memory arbExtraData) internal;\n\n    /// @notice Some inheriting contracts have restrictions on how the arbitrator can be paid.\n    /// This enforces those restrictions.\n    function checkContractSpecificConditionsForCreation(address arbitratorToken) internal;\n\n    /// @dev \u0027_Sometimes_Untrusted_Guarded\u0027 means that in some inheriting contracts it\u0027s\n    /// _Untrusted_Guarded, in some it isn\u0027t. Look at the implementation in the specific\n    /// contract you\u0027re interested in to know.\n    function partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\n        uint agreementID,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        returns (bool);\n\n    /// @notice \u0027Open\u0027 means people should be allowed to take steps toward a future resolution.\n    /// An agreement isn\u0027t open after it has ended (a final resolution exists), or if someone\n    /// withdrew their funds before the second party could deposit theirs.\n    /// @dev partyB can\u0027t do an early withdrawal, so we only need to check if partyA withdrew.\n    function agreementIsOpen(AgreementDataERC20 storage agreement) internal view returns (bool) {\n        // If the tokenA resolution is null then the tokenB one is too, so just check A\n        return agreement.resolutionTokenA == RESOLUTION_NULL \u0026\u0026\n            !partyReceivedDistribution(agreement, Party.A);\n    }\n\n    /// @notice \u0027Locked in\u0027 means both parties have deposited their stake. It conveys that the\n    /// agreement is fully accepted and no one can get money out without someone else\u0027s approval.\n    function agreementIsLockedIn(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return partyStakePaid(agreement, Party.A) \u0026\u0026 partyStakePaid(agreement, Party.B);\n    }\n\n    /// @notice Set or extend the deadline for both parties to pay the arbitration fee.\n    function updateArbitrationResponseDeadline(AgreementDataERC20 storage agreement) internal {\n        agreement.nextArbitrationStepAllowedAfterTimestamp =\n            toUint32(\n                add(\n                    block.timestamp,\n                    mul(agreement.daysToRespondToArbitrationRequest, (1 days))\n                )\n            );\n    }\n\n    /// @notice When both parties have deposited their stakes, the arbitrator is paid any\n    /// \u0027initial\u0027 arbitration fee that was required. We assume we\u0027ve already checked that the\n    /// arbitrator is owed a nonzero amount.\n    function payOutInitialArbitratorFee_Untrusted_Unguarded(\n        AgreementDataERC20 storage agreement\n    )\n        internal\n    {\n        uint totalInitialFeesWei = toWei(\n            add(agreement.partyAInitialArbitratorFee, agreement.partyBInitialArbitratorFee),\n            agreement.arbitratorTokenPower\n        );\n\n        sendFunds_Untrusted_Unguarded(\n            agreement.arbitratorAddress,\n            agreement.arbitratorToken,\n            totalInitialFeesWei\n        );\n    }\n\n    /// @notice Transfers funds from this contract to a given address\n    /// @param to The address to send the funds.\n    /// @param token The address of the token being sent.\n    /// @param amount The amount of wei of the token to send.\n    function sendFunds_Untrusted_Unguarded(\n        address to,\n        address token,\n        uint amount\n    )\n        internal\n    {\n        if (amount == 0) {\n            return;\n        }\n        if (token == address(0)) {\n            // Need to cast to uint160 to make it payable.\n            address(uint160(to)).transfer(amount);\n        } else {\n            require(ERC20Interface(token).transfer(to, amount), \"ERC20 transfer failed.\");\n        }\n    }\n\n    /// @notice Pull ERC20 tokens into this contract from the caller\n    /// @param token The address of the token being pulled.\n    /// @param amount The amount of wei of the token to pulled.\n    function receiveFunds_Untrusted_Unguarded(\n        address token,\n        uint amount\n    )\n        internal\n    {\n        if (token == address(0)) {\n            require(msg.value == amount, \"ETH value received was not what was expected.\");\n        } else if (amount \u003e 0) {\n            require(\n                ERC20Interface(token).transferFrom(msg.sender, address(this), amount),\n                \"ERC20 transfer failed.\"\n            );\n        }\n    }\n\n    /// @notice The depositor needs to send their stake amount (in the token they\u0027re staking), and\n    /// also potentially an initial arbitration fee, in arbitratorToken. This function verifies\n    /// that the current transaction has caused those funds to be moved to our contract.\n    function verifyDeposit_Untrusted_Guarded(\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n    {\n        address partyTokenAddress = partyToken(agreement, party);\n\n        // Make sure people don\u0027t accidentally send ETH when the only required tokens are ERC20\n        if (partyTokenAddress != address(0) \u0026\u0026 agreement.arbitratorToken != address(0)) {\n            require(msg.value == 0, \"ETH was sent, but none was needed.\");\n        }\n\n        // Wrap these receives in a reentrancy guard. (Technically this shouldn\u0027t be necessary,\n        // but that\u0027s not obvious enough to make it worth risking a bug.)\n        bool previousValue = getThenSetPendingExternalCall(agreement, true);\n        if (partyTokenAddress == agreement.arbitratorToken) {\n            // Both tokens we\u0027re receiving are of the same type, so we can do one combined receive\n            receiveFunds_Untrusted_Unguarded(\n                partyTokenAddress,\n                add(\n                    toWei(partyStakeAmount(agreement, party), partyTokenPower(agreement, party)),\n                    toWei(\n                        partyInitialArbitratorFee(agreement, party),\n                        agreement.arbitratorTokenPower\n                    )\n                )\n            );\n        } else {\n            // Tokens are of different types, so do one receive for each.\n            receiveFunds_Untrusted_Unguarded(\n                partyTokenAddress,\n                toWei(partyStakeAmount(agreement, party), partyTokenPower(agreement, party))\n            );\n            receiveFunds_Untrusted_Unguarded(\n                agreement.arbitratorToken,\n                toWei(\n                    partyInitialArbitratorFee(agreement, party),\n                    agreement.arbitratorTokenPower\n                )\n            );\n        }\n        setPendingExternalCall(agreement, previousValue);\n    }\n\n    /// @notice Distribute funds from this contract to the given address, using up to two\n    /// different tokens.\n    /// @param to The address to distribute to.\n    /// @param token1 The first token address\n    /// @param amount1 The amount of token1 to distribute in wei\n    /// @param token2 The second token address\n    /// @param amount2 The amount of token2 to distribute in wei\n    function executeDistribution_Untrusted_Unguarded(\n        address to,\n        address token1,\n        uint amount1,\n        address token2,\n        uint amount2\n    )\n        internal\n    {\n        // All of the calls below are Reentrancy Safe, as they don\u0027t depend on any internal state\n        // nor do they modify any state. You can quickly see this by noting that this function\n        // doesn\u0027t have access to any references to an agreement, so it can\u0027t affect state.\n        if (token1 == token2) {\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount2));\n        } else {\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\n        }\n    }\n\n    /// @notice Distribute funds from this contract to the given address, using up to three\n    /// different tokens.\n    /// @param to The address to distribute to.\n    /// @param token1 The first token address\n    /// @param amount1 The amount of token1 to distribute in wei\n    /// @param token2 The second token address\n    /// @param amount2 The amount of token2 to distribute in wei\n    /// @param token3 The third token address\n    /// @param amount3 The amount of token3 to distribute in wei\n    function executeDistribution_Untrusted_Unguarded(\n        address to,\n        address token1,\n        uint amount1,\n        address token2,\n        uint amount2,\n        address token3,\n        uint amount3\n    )\n        internal\n    {\n        // All of the calls below are Reentrancy Safe, as they don\u0027t depend on any internal state\n        // nor do they modify any state. You can quickly see this by noting that this function\n        // doesn\u0027t have access to any references to an agreement, so it can\u0027t affect state.\n\n        // Check for all combinations of which tokens are the same, to minimize the amount of\n        // transfers.\n        if (token1 == token2 \u0026\u0026 token1 == token3) {\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, add(amount2, amount3)));\n        } else if (token1 == token2) {\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount2));\n            sendFunds_Untrusted_Unguarded(to, token3, amount3);\n        } else if (token1 == token3) {\n            sendFunds_Untrusted_Unguarded(to, token1, add(amount1, amount3));\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\n        } else if (token2 == token3) {\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\n            sendFunds_Untrusted_Unguarded(to, token2, add(amount2, amount3));\n        } else {\n            sendFunds_Untrusted_Unguarded(to, token1, amount1);\n            sendFunds_Untrusted_Unguarded(to, token2, amount2);\n            sendFunds_Untrusted_Unguarded(to, token3, amount3);\n        }\n    }\n\n    /// @notice A helper function that sets the final resolution for the agreement, and\n    /// also distributes funds to the participants based on distributeFundsToParties and\n    /// distributeFundsToArbitrator.\n    function finalizeResolution_Untrusted_Unguarded(\n        uint agreementID,\n        AgreementDataERC20 storage agreement,\n        uint48 resA,\n        uint48 resB,\n        bool distributeFundsToParties,\n        bool distributeFundsToArbitrator\n    )\n        internal\n    {\n        agreement.resolutionTokenA = resA;\n        agreement.resolutionTokenB = resB;\n        calculateDisputeFeeLiability(agreementID, agreement);\n        if (distributeFundsToParties) {\n            emit FundsDistributed(uint32(agreementID));\n            // These calls are not \"Reentrancy Safe\" (see AgreementManager.sol comments).\n            // Using reentrancy guard.\n            bool previousValue = getThenSetPendingExternalCall(agreement, true);\n            distributeFundsToPartyHelper_Untrusted_Unguarded(agreementID, agreement, Party.A);\n            distributeFundsToPartyHelper_Untrusted_Unguarded(agreementID, agreement, Party.B);\n            setPendingExternalCall(agreement, previousValue);\n        }\n        if (distributeFundsToArbitrator) {\n            distributeFundsToArbitratorHelper_Untrusted_Unguarded(agreementID, agreement);\n        }\n    }\n\n    /// @notice This can only be called after a resolution is established.\n    /// A helper function to distribute funds owed to a party based on the resolution and any\n    /// arbitration fee refund they\u0027re owed.\n    /// Assumes that a resolution exists.\n    function distributeFundsToPartyHelper_Untrusted_Unguarded(\n        uint agreementID,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n    {\n        require(!partyReceivedDistribution(agreement, party), \"party already received funds.\");\n        setPartyReceivedDistribution(agreement, party, true);\n\n        uint distributionAmountA = 0;\n        uint distributionAmountB = 0;\n        if (party == Party.A) {\n            distributionAmountA = agreement.resolutionTokenA;\n            distributionAmountB = agreement.resolutionTokenB;\n        } else {\n            distributionAmountA = sub(agreement.partyAStakeAmount, agreement.resolutionTokenA);\n            distributionAmountB = sub(agreement.partyBStakeAmount, agreement.resolutionTokenB);\n        }\n\n        uint arbRefundWei = getPartyArbitrationRefundInWei(agreementID, agreement, party);\n\n        executeDistribution_Untrusted_Unguarded(\n            partyAddress(agreement, party),\n            agreement.partyAToken, toWei(distributionAmountA, agreement.partyATokenPower),\n            agreement.partyBToken, toWei(distributionAmountB, agreement.partyBTokenPower),\n            agreement.arbitratorToken, arbRefundWei);\n    }\n\n    /// @notice A helper function to distribute funds owed to the arbitrator. These funds can be\n    /// distributed either when the arbitrator calls withdrawDisputeFee or resolveAsArbitrator.\n    function distributeFundsToArbitratorHelper_Untrusted_Unguarded(\n        uint agreementID,\n        AgreementDataERC20 storage agreement\n    )\n        internal\n    {\n        require(!arbitratorReceivedDisputeFee(agreement), \"Already received dispute fee.\");\n        setArbitratorReceivedDisputeFee(agreement, true);\n\n        emit ArbitratorReceivedDisputeFee(uint32(agreementID));\n\n        sendFunds_Untrusted_Unguarded(\n            agreement.arbitratorAddress,\n            agreement.arbitratorToken,\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower)\n        );\n    }\n\n    /// @notice Calculate and store in state variables who is responsible for paying any\n    /// arbitration fee (if it was paid).\n    /// @dev\n    /// We set PARTY_A_DISPUTE_FEE_LIABILITY if partyA needs to pay some portion of the fee.\n    /// We set PARTY_B_DISPUTE_FEE_LIABILITY if partyB needs to pay some portion of the fee.\n    /// If both of the above values are true, then partyA and partyB are each liable for half of\n    /// the arbitration fee.\n    function calculateDisputeFeeLiability(\n        uint argreementID,\n        AgreementDataERC20 storage agreement\n    )\n        internal\n    {\n        // If arbitrator hasn\u0027t or won\u0027t get the dispute fee, there\u0027s no liability.\n        if (!arbitratorGetsDisputeFee(argreementID, agreement)) {\n            return;\n        }\n\n        // If A and B have compatible resolutions, then the arbitrator never issued a\n        // ruling. Whichever of partyA and partyB resolved latest should have to pay the full\n        // fee (because if they had resolved earlier, the arbitrator would never have had to be\n        // called). See comments for PARTY_A_RESOLVED_LAST.\n        if (\n            resolutionsAreCompatibleBothExist(\n                agreement,\n                agreement.partyAResolutionTokenA,\n                agreement.partyAResolutionTokenB,\n                agreement.partyBResolutionTokenA,\n                agreement.partyBResolutionTokenB,\n                Party.A\n            )\n        ) {\n            if (partyAResolvedLast(agreement)) {\n                setPartyDisputeFeeLiability(agreement, Party.A, true);\n            } else {\n                setPartyDisputeFeeLiability(agreement, Party.B, true);\n            }\n            return;\n        }\n\n        // Now we know the parties rulings are not compatible with each other. If the ruling\n        // from the arbitrator is compatible with either party, that party pays no fee and the\n        // other party pays the full fee. Otherwise the parties are both liable for half the fee.\n        if (\n            resolutionsAreCompatibleBothExist(\n                agreement,\n                agreement.partyAResolutionTokenA,\n                agreement.partyAResolutionTokenB,\n                agreement.resolutionTokenA,\n                agreement.resolutionTokenB,\n                Party.A\n            )\n        ) {\n            setPartyDisputeFeeLiability(agreement, Party.B, true);\n        } else if (\n            resolutionsAreCompatibleBothExist(\n                agreement,\n                agreement.partyBResolutionTokenA,\n                agreement.partyBResolutionTokenB,\n                agreement.resolutionTokenA,\n                agreement.resolutionTokenB,\n                Party.B\n            )\n        ) {\n            setPartyDisputeFeeLiability(agreement, Party.A, true);\n        } else {\n            setPartyDisputeFeeLiability(agreement, Party.A, true);\n            setPartyDisputeFeeLiability(agreement, Party.B, true);\n        }\n    }\n\n    /// @return whether the arbitrator has either already gotten or is entitled to withdraw\n    /// the dispute fee\n    function arbitratorGetsDisputeFee(\n        uint argreementID,\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        returns (bool);\n}\n"},"AgreementManagerERC20_Simple.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./AgreementManagerERC20.sol\";\nimport \"./SimpleArbitrationInterface.sol\";\n\n/**\n    @notice\n    See AgreementManager for comments on the overall nature of this contract.\n\n    This is the contract defining how ERC20 agreements with simple (non-ERC792)\n    arbitration work.\n\n    @dev\n    The relevant part of the inheritance tree is:\n    AgreementManager\n        AgreementManagerERC20\n            AgreementManagerERC20_Simple\n\n    We also inherit from SimpleArbitrationInterface, a very simple interface that lets us avoid\n    a small amount of code duplication for non-ERC792 arbitration.\n\n    There should be no risk of re-entrancy attacks in this contract, since it makes no external\n    calls aside from ETH and ERC20 transfers which always occur in ways that are Reentrancy Safe\n    (see the comments in AgreementManager.sol for the meaning of \"Reentrancy Safe\").\n\n    Search AgreementManager.sol for \"NOTES ON REENTRANCY\" to learn more about our reentrancy\n    protection strategy.\n*/\n\ncontract AgreementManagerERC20_Simple is AgreementManagerERC20, SimpleArbitrationInterface {\n    // -------------------------------------------------------------------------------------------\n    // ------------------------------------- events ----------------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    event ArbitratorResolved(\n        uint32 indexed agreementID,\n        uint resolutionTokenA,\n        uint resolutionTokenB\n    );\n\n    // -------------------------------------------------------------------------------------------\n    // ---------------------------- external getter functions ------------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    // Return a bunch of arrays representing the entire state of the agreement.\n    function getState(\n        uint agreementID\n    )\n        external\n        view\n        returns (address[6] memory, uint[23] memory, bool[12] memory, bytes memory)\n    {\n        if (agreementID \u003e= agreements.length) {\n            address[6] memory zeroAddrs;\n            uint[23] memory zeroUints;\n            bool[12] memory zeroBools;\n            bytes memory zeroBytes;\n            return (zeroAddrs, zeroUints, zeroBools, zeroBytes);\n        }\n\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        address[6] memory addrs = [\n            agreement.partyAAddress,\n            agreement.partyBAddress,\n            agreement.arbitratorAddress,\n            agreement.partyAToken,\n            agreement.partyBToken,\n            agreement.arbitratorToken\n        ];\n        uint[23] memory uints = [\n            resolutionToWei(agreement.partyAResolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(agreement.partyAResolutionTokenB, agreement.partyBTokenPower),\n            resolutionToWei(agreement.partyBResolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(agreement.partyBResolutionTokenB, agreement.partyBTokenPower),\n            resolutionToWei(agreement.resolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(agreement.resolutionTokenB, agreement.partyBTokenPower),\n            resolutionToWei(agreement.automaticResolutionTokenA, agreement.partyATokenPower),\n            resolutionToWei(agreement.automaticResolutionTokenB, agreement.partyBTokenPower),\n            toWei(agreement.partyAStakeAmount, agreement.partyATokenPower),\n            toWei(agreement.partyBStakeAmount, agreement.partyBTokenPower),\n            toWei(agreement.partyAInitialArbitratorFee, agreement.arbitratorTokenPower),\n            toWei(agreement.partyBInitialArbitratorFee, agreement.arbitratorTokenPower),\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower),\n            agreement.nextArbitrationStepAllowedAfterTimestamp,\n            agreement.autoResolveAfterTimestamp,\n            agreement.daysToRespondToArbitrationRequest,\n            agreement.partyATokenPower,\n            agreement.partyBTokenPower,\n            agreement.arbitratorTokenPower,\n            // Return a bunch of zeroes where the ERC792 arbitration data is so we can have the\n            // same API for both\n            0,\n            0,\n            0,\n            0\n        ];\n        bool[12] memory boolVals = [\n            partyStakePaid(agreement, Party.A),\n            partyStakePaid(agreement, Party.B),\n            partyRequestedArbitration(agreement, Party.A),\n            partyRequestedArbitration(agreement, Party.B),\n            partyReceivedDistribution(agreement, Party.A),\n            partyReceivedDistribution(agreement, Party.B),\n            partyAResolvedLast(agreement),\n            arbitratorResolved(agreement),\n            arbitratorReceivedDisputeFee(agreement),\n            partyDisputeFeeLiability(agreement, Party.A),\n            partyDisputeFeeLiability(agreement, Party.B),\n            // Return a false value where the ERC792 arbitration data is so we can have the\n            // same API for both\n            false\n        ];\n        // Return empty bytes value to keep the same API as for the ERC792 version\n        bytes memory bytesVal;\n\n        return (addrs, uints, boolVals, bytesVal);\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // -------------------- main external/public functions that affect state ---------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @notice Called by arbitrator to report their resolution.\n    /// Can only be called after arbitrator is asked to arbitrate by both parties.\n    /// We separate the staked funds of party A and party B because they might use different\n    /// tokens.\n    /// @param resTokenA The amount of party A\u0027s staked funds that the caller thinks should go to\n    ///  party A. The remaining amount of wei staked for this agreement would go to party B.\n    /// @param resTokenB The amount of party B\u0027s staked funds that the caller thinks should go to\n    ///  party A. The remaining amount of wei staked for this agreement would go to party B.\n    /// @param distributeFunds Whether to distribute funds to both parties and the arbitrator (if\n    /// the arbitrator hasn\u0027t already called withdrawDisputeFee).\n    function resolveAsArbitrator(\n        uint agreementID,\n        uint resTokenA,\n        uint resTokenB,\n        bool distributeFunds\n    )\n        external\n    {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(agreementIsLockedIn(agreement), \"Agreement not locked in.\");\n\n        uint48 resA = toLargerUnit(resTokenA, agreement.partyATokenPower);\n        uint48 resB = toLargerUnit(resTokenB, agreement.partyBTokenPower);\n\n        require(\n            msg.sender == agreement.arbitratorAddress,\n            \"resolveAsArbitrator can only be called by arbitrator.\"\n        );\n        require(resA \u003c= agreement.partyAStakeAmount, \"Resolution out of range for token A.\");\n        require(resB \u003c= agreement.partyBStakeAmount, \"Resolution out of range for token B.\");\n        require(\n            (\n                partyRequestedArbitration(agreement, Party.A) \u0026\u0026\n                partyRequestedArbitration(agreement, Party.B)\n            ),\n            \"Arbitration not requested by both parties.\"\n        );\n\n        setArbitratorResolved(agreement, true);\n\n        emit ArbitratorResolved(uint32(agreementID), resA, resB);\n\n        bool distributeToArbitrator = !arbitratorReceivedDisputeFee(agreement) \u0026\u0026 distributeFunds;\n\n        finalizeResolution_Untrusted_Unguarded(\n            agreementID,\n            agreement,\n            resA,\n            resB,\n            distributeFunds,\n            distributeToArbitrator\n        );\n    }\n\n    /// @notice Request that the arbitrator get involved to settle the disagreement.\n    /// Each party needs to pay the full arbitration fee when calling this. However they will be\n    /// refunded the full fee if the arbitrator agrees with them.\n    /// If one party calls this and the other refuses to, the party who called this function can\n    /// eventually call requestDefaultJudgment.\n    function requestArbitration(uint agreementID) external payable {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\n        require(agreementIsOpen(agreement), \"Agreement not open.\");\n        require(agreementIsLockedIn(agreement), \"Agreement not locked in.\");\n        require(agreement.arbitratorAddress != address(0), \"Arbitration is disallowed.\");\n        // Make sure people don\u0027t accidentally send ETH when the only required tokens are ERC20\n        if (agreement.arbitratorToken != address(0)) {\n            require(msg.value == 0, \"ETH was sent, but none was needed.\");\n        }\n\n        Party callingParty = getCallingParty(agreement);\n        require(\n            !partyResolutionIsNull(agreement, callingParty),\n            \"Need to enter a resolution before requesting arbitration.\"\n        );\n        require(\n            !partyRequestedArbitration(agreement, callingParty),\n            \"This party already requested arbitration.\"\n        );\n\n        bool firstArbitrationRequest =\n            !partyRequestedArbitration(agreement, Party.A) \u0026\u0026\n            !partyRequestedArbitration(agreement, Party.B);\n\n        require(\n            (\n                !firstArbitrationRequest ||\n                block.timestamp \u003e agreement.nextArbitrationStepAllowedAfterTimestamp\n            ),\n            \"Arbitration not allowed yet.\"\n        );\n\n        setPartyRequestedArbitration(agreement, callingParty, true);\n\n        emit ArbitrationRequested(uint32(agreementID));\n\n        if (firstArbitrationRequest) {\n            updateArbitrationResponseDeadline(agreement);\n        } else {\n            // Both parties have requested arbitration. Emit this event to conform to ERC1497.\n            emit Dispute(\n                Arbitrator(agreement.arbitratorAddress),\n                agreementID,\n                agreementID,\n                agreementID\n            );\n        }\n\n        receiveFunds_Untrusted_Unguarded(\n            agreement.arbitratorToken,\n            toWei(agreement.disputeFee, agreement.arbitratorTokenPower)\n        );\n    }\n\n    /// @notice Allow the arbitrator to indicate they\u0027re working on the dispute by withdrawing the\n    /// funds. We can\u0027t prevent dishonest arbitrator from taking funds without doing work, because\n    /// they can always call \u0027resolveAsArbitrator\u0027 quickly. So we prevent the arbitrator from\n    /// actually being paid until they either call this function or \u0027resolveAsArbitrator\u0027 to avoid\n    /// the case where we send funds to a nonresponsive arbitrator.\n    function withdrawDisputeFee(uint agreementID) external {\n        AgreementDataERC20 storage agreement = agreements[agreementID];\n\n        require(!pendingExternalCall(agreement), \"Reentrancy protection is on\");\n        require(\n            (\n                partyRequestedArbitration(agreement, Party.A) \u0026\u0026\n                partyRequestedArbitration(agreement, Party.B)\n            ),\n            \"Arbitration not requested\"\n        );\n        require(\n            msg.sender == agreement.arbitratorAddress,\n            \"withdrawDisputeFee can only be called by Arbitrator.\"\n        );\n        require(\n            !resolutionsAreCompatibleBothExist(\n                agreement,\n                agreement.partyAResolutionTokenA,\n                agreement.partyAResolutionTokenB,\n                agreement.partyBResolutionTokenA,\n                agreement.partyBResolutionTokenB,\n                Party.A\n            ),\n            \"partyA and partyB already resolved their dispute.\"\n        );\n\n        distributeFundsToArbitratorHelper_Untrusted_Unguarded(agreementID, agreement);\n    }\n\n    // -------------------------------------------------------------------------------------------\n    // ----------------------------- internal helper functions -----------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @dev This functions is a no-op in this version of the contract. It exists because we use\n    /// inheritance.\n    function checkContractSpecificConditionsForCreation(address arbitratorToken) internal { }\n\n    /// @dev This function is NOT untrusted in this contract.\n    /// @return whether the given party has paid the arbitration fee in full.\n    function partyFullyPaidDisputeFee_Sometimes_Untrusted_Guarded(\n        uint, /*agreementID is unused in this version*/\n        AgreementDataERC20 storage agreement,\n        Party party) internal returns (bool) {\n\n        // Since the arbitration fee can\u0027t change mid-agreement in simple arbitration,\n        // having requested arbitration means the dispute fee is paid.\n        return partyRequestedArbitration(agreement, party);\n    }\n\n    /// @return Whether the party provided is closer to winning a default judgment than the other\n    /// party. For simple arbitration this means just that they\u0027d paid the arbitration fee\n    /// and the other party hasn\u0027t.\n    function partyIsCloserToWinningDefaultJudgment(\n        uint /*agreementID*/,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        returns (bool)\n    {\n        return partyRequestedArbitration(agreement, party) \u0026\u0026\n            !partyRequestedArbitration(agreement, getOtherParty(party));\n    }\n\n    /// @notice See comments in AgreementManagerETH to understand the goal of this\n    /// important function.\n    /// @dev We don\u0027t use the first argument (agreementID) in this version, but it\u0027s there because\n    /// we use inheritance.\n    function getPartyArbitrationRefundInWei(\n        uint /*agreementID*/,\n        AgreementDataERC20 storage agreement,\n        Party party\n    )\n        internal\n        view\n        returns (uint)\n    {\n        if (!partyRequestedArbitration(agreement, party)) {\n            // party didn\u0027t pay an arbitration fee, so gets no refund.\n            return 0;\n        }\n\n        // Now we know party paid an arbitration fee, so figure out how much of it they get back.\n\n        if (partyDisputeFeeLiability(agreement, party)) {\n            // party has liability for the dispute fee. The only question is whether they\n            // pay the full amount or half.\n            Party otherParty = getOtherParty(party);\n            if (partyDisputeFeeLiability(agreement, otherParty)) {\n                // party pays half the fee\n                return toWei(agreement.disputeFee/2, agreement.arbitratorTokenPower);\n            }\n            return 0; // party pays the full fee\n        }\n        // No liability -- full refund\n        return toWei(agreement.disputeFee, agreement.arbitratorTokenPower);\n    }\n\n    /// @return whether the arbitrator has either already received or is entitled to withdraw\n    /// the dispute fee\n    function arbitratorGetsDisputeFee(\n        uint /*agreementID*/,\n        AgreementDataERC20 storage agreement\n    )\n        internal\n        returns (bool)\n    {\n        return arbitratorResolved(agreement) || arbitratorReceivedDisputeFee(agreement);\n    }\n}\n"},"Arbitrable.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./Arbitrator.sol\";\n\ncontract Arbitrable {\n\n    function rule(uint _dispute, uint _ruling) public;\n\n    event Ruling(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _ruling);\n}"},"Arbitrator.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./Arbitrable.sol\";\n\n/** @title Arbitrator\n *  Arbitrator abstract contract.\n *  When developing arbitrator contracts we need to:\n *  -Define the functions for dispute creation (createDispute) and appeal (appeal). Don\u0027t forget to store the arbitrated contract and the disputeID (which should be unique, use nbDisputes).\n *  -Define the functions for cost display (arbitrationCost and appealCost).\n *  -Allow giving rulings. For this a function must call arbitrable.rule(disputeID, ruling).\n */\ncontract Arbitrator {\n\n    enum DisputeStatus { Waiting, Appealable, Solved }\n\n    /** @dev To be raised when a dispute is created.\n     *  @param _disputeID ID of the dispute.\n     *  @param _arbitrable The contract which created the dispute.\n     */\n    event DisputeCreation(uint indexed _disputeID, Arbitrable indexed _arbitrable);\n\n    /** @dev To be raised when a dispute can be appealed.\n     *  @param _disputeID ID of the dispute.\n     */\n    event AppealPossible(uint indexed _disputeID, Arbitrable indexed _arbitrable);\n\n    /** @dev To be raised when the current ruling is appealed.\n     *  @param _disputeID ID of the dispute.\n     *  @param _arbitrable The contract which created the dispute.\n     */\n    event AppealDecision(uint indexed _disputeID, Arbitrable indexed _arbitrable);\n\n    /** @dev Create a dispute. Must be called by the arbitrable contract.\n     *  Must be paid at least arbitrationCost(_extraData).\n     *  @param _choices Amount of choices the arbitrator can make in this dispute.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return disputeID ID of the dispute created.\n     */\n    function createDispute(uint _choices, bytes memory _extraData) public payable returns(uint disputeID);\n\n    /** @dev Compute the cost of arbitration. It is recommended not to increase it often, as it can be highly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return fee Amount to be paid.\n     */\n    function arbitrationCost(bytes memory _extraData) public view returns(uint fee);\n\n    /** @dev Appeal a ruling. Note that it has to be called before the arbitrator contract calls rule.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Can be used to give extra info on the appeal.\n     */\n    function appeal(uint _disputeID, bytes memory _extraData) public payable;\n\n    /** @dev Compute the cost of appeal. It is recommended not to increase it often, as it can be higly time and gas consuming for the arbitrated contracts to cope with fee augmentation.\n     *  @param _disputeID ID of the dispute to be appealed.\n     *  @param _extraData Can be used to give additional info on the dispute to be created.\n     *  @return fee Amount to be paid.\n     */\n    function appealCost(uint _disputeID, bytes memory _extraData) public view returns(uint fee);\n\n    /** @dev Compute the start and end of the dispute\u0027s current or next appeal period, if possible.\n     *  @param _disputeID ID of the dispute.\n     *  @return The start and end of the period.\n     */\n    function appealPeriod(uint _disputeID) public view returns(uint start, uint end);\n\n    /** @dev Return the status of a dispute.\n     *  @param _disputeID ID of the dispute to rule.\n     *  @return status The status of the dispute.\n     */\n    function disputeStatus(uint _disputeID) public view returns(DisputeStatus status);\n\n    /** @dev Return the current ruling of a dispute. This is useful for parties to know if they should appeal.\n     *  @param _disputeID ID of the dispute.\n     *  @return ruling The ruling which has been given or the one which will be given if there is no appeal.\n     */\n    function currentRuling(uint _disputeID) public view returns(uint ruling);\n}"},"ERC20Interface.sol":{"content":"pragma solidity 0.5.3;\n\ncontract ERC20Interface {\n    function totalSupply() public view returns (uint);\n    function balanceOf(address tokenOwner) public view returns (uint balance);\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\n    function transfer(address to, uint tokens) public returns (bool success);\n    function approve(address spender, uint tokens) public returns (bool success);\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\n\n    event Transfer(address indexed from, address indexed to, uint tokens);\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\n}"},"EvidenceProducer.sol":{"content":"pragma solidity 0.5.3;\n\nimport \"./Arbitrator.sol\";\n\n// See ERC 1497\ncontract EvidenceProducer {\n    event MetaEvidence(uint indexed _metaEvidenceID, string _evidence);\n    event Dispute(Arbitrator indexed _arbitrator, uint indexed _disputeID, uint _metaEvidenceID, uint _evidenceGroupID);\n    event Evidence(Arbitrator indexed _arbitrator, uint indexed _evidenceGroupID, address indexed _party, string _evidence);\n}"},"SafeUtils.sol":{"content":"pragma solidity 0.5.3;\n\ncontract SafeUtils {\n    function toUint48(uint val) internal pure returns (uint48) {\n        uint48 ret = uint48(val);\n        require(ret == val, \"toUint48 lost some value.\");\n        return ret;\n    }\n    function toUint32(uint val) internal pure returns (uint32) {\n        uint32 ret = uint32(val);\n        require(ret == val, \"toUint32 lost some value.\");\n        return ret;\n    }\n    function toUint16(uint val) internal pure returns (uint16) {\n        uint16 ret = uint16(val);\n        require(ret == val, \"toUint16 lost some value.\");\n        return ret;\n    }\n    function toUint8(uint val) internal pure returns (uint8) {\n        uint8 ret = uint8(val);\n        require(ret == val, \"toUint8 lost some value.\");\n        return ret;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring \u0027a\u0027 not being zero, but the\n        // benefit is lost if \u0027b\u0027 is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"Bad safe math multiplication.\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b \u003e 0, \"Attempt to divide by zero in safe math.\");\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b \u003c= a, \"Bad subtraction in safe math.\");\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c \u003e= a, \"Bad addition in safe math.\");\n\n        return c;\n    }\n}"},"SimpleArbitrationInterface.sol":{"content":"pragma solidity 0.5.3;\n\n/**\n    @notice A contract that AgreementManagers that implement simple (non-ERC792) arbitration can\n    inherit from.\n\n    This is currently too simple to be that useful, but things may be added to it in the future.\n*/\n\ncontract SimpleArbitrationInterface {\n    // -------------------------------------------------------------------------------------------\n    // ----------------------------- internal helper functions -----------------------------------\n    // -------------------------------------------------------------------------------------------\n\n    /// @dev This is a no-op when using simple arbitration.\n    /// Extra arbitration data is only needed for ERC792 arbitration.\n    function storeArbitrationExtraData(uint, bytes memory) internal { }\n}\n"}}