{"AddressUtils.sol":{"content":"pragma solidity ^0.4.18;\n\n\n/**\n * Utility library of inline functions on addresses\n */\nlibrary AddressUtils {\n\n  /**\n   * Returns whether the target address is a contract\n   * @dev This function will return false if invoked during the constructor of a contract,\n   *  as the code is not actually created until after the constructor finishes.\n   * @param addr address to check\n   * @return whether the target address is a contract\n   */\n  function isContract(address addr) internal view returns (bool) {\n    uint256 size;\n    // XXX Currently there is no better way to check if there is a contract in an address\n    // than to check the size of the code at that address.\n    // See https://ethereum.stackexchange.com/a/14016/36603\n    // for more details about how this works.\n    // TODO Check this again before the Serenity release, because all addresses will be\n    // contracts then.\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\n    return size \u003e 0;\n  }\n\n}\n"},"DelegateProxy.sol":{"content":"pragma solidity ^0.4.18;\n\ncontract DelegateProxy {\n  /**\n  * @dev Performs a delegatecall and returns whatever the delegatecall returned (entire context execution will return!)\n  * @param _dst Destination address to perform the delegatecall\n  * @param _calldata Calldata for the delegatecall\n  */\n  function delegatedFwd(address _dst, bytes _calldata) internal {\n    require(isContract(_dst));\n    assembly {\n      let result := delegatecall(sub(gas, 10000), _dst, add(_calldata, 0x20), mload(_calldata), 0, 0)\n      let size := returndatasize\n\n      let ptr := mload(0x40)\n      returndatacopy(ptr, 0, size)\n\n    // revert instead of invalid() bc if the underlying call failed with invalid() it already wasted gas.\n    // if the call returned error data, forward it\n      switch result case 0 {revert(ptr, size)}\n      default {return (ptr, size)}\n    }\n  }\n\n  function isContract(address _target) internal view returns (bool) {\n    uint256 size;\n    assembly {size := extcodesize(_target)}\n    return size \u003e 0;\n  }\n}"},"DSAuth.sol":{"content":"// This program is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n\n// This program is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n\n// You should have received a copy of the GNU General Public License\n// along with this program.  If not, see \u003chttp://www.gnu.org/licenses/\u003e.\n\npragma solidity ^0.4.13;\n\ncontract DSAuthority {\n  function canCall(\n    address src, address dst, bytes4 sig\n  ) public view returns (bool);\n}\n\ncontract DSAuthEvents {\n  event LogSetAuthority (address indexed authority);\n  event LogSetOwner     (address indexed owner);\n}\n\ncontract DSAuth is DSAuthEvents {\n  DSAuthority  public  authority;\n  address      public  owner;\n\n  function DSAuth() public {\n    owner = msg.sender;\n    LogSetOwner(msg.sender);\n  }\n\n  function setOwner(address owner_)\n  public\n  auth\n  {\n    owner = owner_;\n    LogSetOwner(owner);\n  }\n\n  function setAuthority(DSAuthority authority_)\n  public\n  auth\n  {\n    authority = authority_;\n    LogSetAuthority(authority);\n  }\n\n  modifier auth {\n    require(isAuthorized(msg.sender, msg.sig));\n    _;\n  }\n\n  function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\n    if (src == address(this)) {\n      return true;\n    } else if (src == owner) {\n      return true;\n    } else if (authority == DSAuthority(0)) {\n      return false;\n    } else {\n      return authority.canCall(src, this, sig);\n    }\n  }\n}\n"},"ERC721.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC721Basic.sol\";\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Enumerable is ERC721Basic {\n  function totalSupply() public view returns (uint256);\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\n  function tokenByIndex(uint256 _index) public view returns (uint256);\n}\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Metadata is ERC721Basic {\n  function name() public view returns (string _name);\n  function symbol() public view returns (string _symbol);\n  function tokenURI(uint256 _tokenId) public view returns (address);\n}\n\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\n}\n"},"ERC721Basic.sol":{"content":"pragma solidity ^0.4.18;\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic interface\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Basic {\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId, uint256 _timestamp);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n  function balanceOf(address _owner) public view returns (uint256 _balance);\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\n  function exists(uint256 _tokenId) public view returns (bool _exists);\n\n  function approve(address _to, uint256 _tokenId) public;\n  function getApproved(uint256 _tokenId) public view returns (address _operator);\n\n  function setApprovalForAll(address _operator, bool _approved) public;\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes _data\n  )\n  public;\n}\n"},"ERC721BasicToken.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC721Basic.sol\";\nimport \"./ERC721Receiver.sol\";\nimport \"./SafeMath.sol\";\nimport \"./AddressUtils.sol\";\n\n\n/**\n * @title ERC721 Non-Fungible Token Standard basic implementation\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721BasicToken is ERC721Basic {\n  using SafeMath for uint256;\n  using AddressUtils for address;\n\n  // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n  // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  // Mapping from token ID to owner\n  mapping (uint256 =\u003e address) internal tokenOwner;\n\n  // Mapping from token ID to approved address\n  mapping (uint256 =\u003e address) internal tokenApprovals;\n\n  // Mapping from owner to number of owned token\n  mapping (address =\u003e uint256) internal ownedTokensCount;\n\n  // Mapping from owner to operator approvals\n  mapping (address =\u003e mapping (address =\u003e bool)) internal operatorApprovals;\n\n  /**\n  * @dev Guarantees msg.sender is owner of the given token\n  * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\n  */\n  modifier onlyOwnerOf(uint256 _tokenId) {\n    require(ownerOf(_tokenId) == msg.sender);\n    _;\n  }\n\n  /**\n  * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\n  * @param _tokenId uint256 ID of the token to validate\n  */\n  modifier canTransfer(uint256 _tokenId) {\n    require(isApprovedOrOwner(msg.sender, _tokenId));\n    _;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address\n  * @param _owner address to query the balance of\n  * @return uint256 representing the amount owned by the passed address\n  */\n  function balanceOf(address _owner) public view returns (uint256) {\n    require(_owner != address(0));\n    return ownedTokensCount[_owner];\n  }\n\n  /**\n  * @dev Gets the owner of the specified token ID\n  * @param _tokenId uint256 ID of the token to query the owner of\n  * @return owner address currently marked as the owner of the given token ID\n  */\n  function ownerOf(uint256 _tokenId) public view returns (address) {\n    address owner = tokenOwner[_tokenId];\n    require(owner != address(0));\n    return owner;\n  }\n\n  /**\n  * @dev Returns whether the specified token exists\n  * @param _tokenId uint256 ID of the token to query the existance of\n  * @return whether the token exists\n  */\n  function exists(uint256 _tokenId) public view returns (bool) {\n    address owner = tokenOwner[_tokenId];\n    return owner != address(0);\n  }\n\n  /**\n  * @dev Approves another address to transfer the given token ID\n  * @dev The zero address indicates there is no approved address.\n  * @dev There can only be one approved address per token at a given time.\n  * @dev Can only be called by the token owner or an approved operator.\n  * @param _to address to be approved for the given token ID\n  * @param _tokenId uint256 ID of the token to be approved\n  */\n  function approve(address _to, uint256 _tokenId) public {\n    address owner = ownerOf(_tokenId);\n    require(_to != owner);\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\n      tokenApprovals[_tokenId] = _to;\n      Approval(owner, _to, _tokenId);\n    }\n  }\n\n  /**\n   * @dev Gets the approved address for a token ID, or zero if no address set\n   * @param _tokenId uint256 ID of the token to query the approval of\n   * @return address currently approved for a the given token ID\n   */\n  function getApproved(uint256 _tokenId) public view returns (address) {\n    return tokenApprovals[_tokenId];\n  }\n\n  /**\n  * @dev Sets or unsets the approval of a given operator\n  * @dev An operator is allowed to transfer all tokens of the sender on their behalf\n  * @param _to operator address to set the approval\n  * @param _approved representing the status of the approval to be set\n  */\n  function setApprovalForAll(address _to, bool _approved) public {\n    require(_to != msg.sender);\n    operatorApprovals[msg.sender][_to] = _approved;\n    ApprovalForAll(msg.sender, _to, _approved);\n  }\n\n  /**\n   * @dev Tells whether an operator is approved by a given owner\n   * @param _owner owner address which you want to query the approval of\n   * @param _operator operator address which you want to query the approval of\n   * @return bool whether the given operator is approved by the given owner\n   */\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\n    return operatorApprovals[_owner][_operator];\n  }\n\n  /**\n  * @dev Transfers the ownership of a given token ID to another address\n  * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n  * @dev Requires the msg sender to be the owner, approved, or operator\n  * @param _from current owner of the token\n  * @param _to address to receive the ownership of the given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) {\n    require(_from != address(0));\n    require(_to != address(0));\n\n    clearApproval(_from, _tokenId);\n    removeTokenFrom(_from, _tokenId);\n    addTokenTo(_to, _tokenId);\n\n    Transfer(_from, _to, _tokenId, now);\n  }\n\n  /**\n  * @dev Safely transfers the ownership of a given token ID to another address\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\n  *  which is called upon a safe transfer, and return the magic value\n  *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n  *  the transfer is reverted.\n  * @dev Requires the msg sender to be the owner, approved, or operator\n  * @param _from current owner of the token\n  * @param _to address to receive the ownership of the given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n  public\n  canTransfer(_tokenId)\n  {\n    safeTransferFrom(_from, _to, _tokenId, \"\");\n  }\n\n  /**\n  * @dev Safely transfers the ownership of a given token ID to another address\n  * @dev If the target address is a contract, it must implement `onERC721Received`,\n  *  which is called upon a safe transfer, and return the magic value\n  *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\n  *  the transfer is reverted.\n  * @dev Requires the msg sender to be the owner, approved, or operator\n  * @param _from current owner of the token\n  * @param _to address to receive the ownership of the given token ID\n  * @param _tokenId uint256 ID of the token to be transferred\n  * @param _data bytes data to send along with a safe transfer check\n  */\n  function safeTransferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes _data\n  )\n  public\n  canTransfer(_tokenId)\n  {\n    transferFrom(_from, _to, _tokenId);\n    require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n  }\n\n  /**\n   * @dev Returns whether the given spender can transfer a given token ID\n   * @param _spender address of the spender to query\n   * @param _tokenId uint256 ID of the token to be transferred\n   * @return bool whether the msg.sender is approved for the given token ID,\n   *  is an operator of the owner, or is the owner of the token\n   */\n  function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) {\n    address owner = ownerOf(_tokenId);\n    return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender);\n  }\n\n  /**\n  * @dev Internal function to mint a new token\n  * @dev Reverts if the given token ID already exists\n  * @param _to The address that will own the minted token\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n  */\n  function _mint(address _to, uint256 _tokenId) internal {\n    require(_to != address(0));\n    addTokenTo(_to, _tokenId);\n    Transfer(address(0), _to, _tokenId, now);\n  }\n\n  /**\n  * @dev Internal function to burn a specific token\n  * @dev Reverts if the token does not exist\n  * @param _tokenId uint256 ID of the token being burned by the msg.sender\n  */\n  function _burn(address _owner, uint256 _tokenId) internal {\n    clearApproval(_owner, _tokenId);\n    removeTokenFrom(_owner, _tokenId);\n    Transfer(_owner, address(0), _tokenId, now);\n  }\n\n  /**\n  * @dev Internal function to clear current approval of a given token ID\n  * @dev Reverts if the given address is not indeed the owner of the token\n  * @param _owner owner of the token\n  * @param _tokenId uint256 ID of the token to be transferred\n  */\n  function clearApproval(address _owner, uint256 _tokenId) internal {\n    require(ownerOf(_tokenId) == _owner);\n    if (tokenApprovals[_tokenId] != address(0)) {\n      tokenApprovals[_tokenId] = address(0);\n      Approval(_owner, address(0), _tokenId);\n    }\n  }\n\n  /**\n  * @dev Internal function to add a token ID to the list of a given address\n  * @param _to address representing the new owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n  */\n  function addTokenTo(address _to, uint256 _tokenId) internal {\n    require(tokenOwner[_tokenId] == address(0));\n    tokenOwner[_tokenId] = _to;\n    ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\n  }\n\n  /**\n  * @dev Internal function to remove a token ID from the list of a given address\n  * @param _from address representing the previous owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n  */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n    require(ownerOf(_tokenId) == _from);\n    ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\n    tokenOwner[_tokenId] = address(0);\n  }\n\n  /**\n  * @dev Internal function to invoke `onERC721Received` on a target address\n  * @dev The call is not executed if the target address is not a contract\n  * @param _from address representing the previous owner of the given token ID\n  * @param _to target address that will receive the tokens\n  * @param _tokenId uint256 ID of the token to be transferred\n  * @param _data bytes optional data to send along with the call\n  * @return whether the call correctly returned the expected magic value\n  */\n  function checkAndCallSafeTransfer(\n    address _from,\n    address _to,\n    uint256 _tokenId,\n    bytes _data\n  )\n  internal\n  returns (bool)\n  {\n    if (!_to.isContract()) {\n      return true;\n    }\n    bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data);\n    return (retval == ERC721_RECEIVED);\n  }\n}\n"},"ERC721Holder.sol":{"content":"pragma solidity ^0.4.21;\n\nimport \"./ERC721Receiver.sol\";\n\n\ncontract ERC721Holder is ERC721Receiver {\n  function onERC721Received(address, uint256, bytes) public returns(bytes4) {\n    return ERC721_RECEIVED;\n  }\n}\n"},"ERC721Receiver.sol":{"content":"pragma solidity ^0.4.21;\n\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n *  from ERC721 asset contracts.\n */\ncontract ERC721Receiver {\n  /**\n   * @dev Magic value to be returned upon successful reception of an NFT\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n   */\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\n\n  /**\n   * @notice Handle the receipt of an NFT\n   * @dev The ERC721 smart contract calls this function on the recipient\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\n   *  than the magic value MUST result in the transaction being reverted.\n   *  Note: the contract address is always the message sender.\n   * @param _from The sending address\n   * @param _tokenId The NFT identifier which is being transfered\n   * @param _data Additional data with no specified format\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\n   */\n  function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4);\n}\n"},"ERC721Token.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./ERC721.sol\";\nimport \"./ERC721BasicToken.sol\";\n\n\n/**\n * @title Full ERC721 Token\n * This implementation includes all the required and some optional functionality of the ERC721 standard\n * Moreover, it includes approve all functionality using operator terminology\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\n */\ncontract ERC721Token is ERC721, ERC721BasicToken {\n  // Token name\n  string internal name_;\n\n  // Token symbol\n  string internal symbol_;\n\n  // Mapping from owner to list of owned token IDs\n  mapping(address =\u003e uint256[]) internal ownedTokens;\n\n  // Mapping from token ID to index of the owner tokens list\n  mapping(uint256 =\u003e uint256) internal ownedTokensIndex;\n\n  // Array with all token ids, used for enumeration\n  uint256[] internal allTokens;\n\n  // Mapping from token id to position in the allTokens array\n  mapping(uint256 =\u003e uint256) internal allTokensIndex;\n\n  // Optional mapping for token URIs\n  mapping(uint256 =\u003e address) internal tokenURIs;\n\n  /**\n  * @dev Constructor function\n  */\n  function ERC721Token(string _name, string _symbol) public {\n    name_ = _name;\n    symbol_ = _symbol;\n  }\n\n  /**\n  * @dev Gets the token name\n  * @return string representing the token name\n  */\n  function name() public view returns (string) {\n    return name_;\n  }\n\n  /**\n  * @dev Gets the token symbol\n  * @return string representing the token symbol\n  */\n  function symbol() public view returns (string) {\n    return symbol_;\n  }\n\n  /**\n  * @dev Returns an URI for a given token ID\n  * @dev Throws if the token ID does not exist. May return an empty string.\n  * @param _tokenId uint256 ID of the token to query\n  */\n  function tokenURI(uint256 _tokenId) public view returns (address) {\n    require(exists(_tokenId));\n    return tokenURIs[_tokenId];\n  }\n\n  /**\n  * @dev Gets the token ID at a given index of the tokens list of the requested owner\n  * @param _owner address owning the tokens list to be accessed\n  * @param _index uint256 representing the index to be accessed of the requested tokens list\n  * @return uint256 token ID at the given index of the tokens list owned by the requested address\n  */\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) {\n    require(_index \u003c balanceOf(_owner));\n    return ownedTokens[_owner][_index];\n  }\n\n  /**\n  * @dev Gets the total amount of tokens stored by the contract\n  * @return uint256 representing the total amount of tokens\n  */\n  function totalSupply() public view returns (uint256) {\n    return allTokens.length;\n  }\n\n  /**\n  * @dev Gets the token ID at a given index of all the tokens in this contract\n  * @dev Reverts if the index is greater or equal to the total number of tokens\n  * @param _index uint256 representing the index to be accessed of the tokens list\n  * @return uint256 token ID at the given index of the tokens list\n  */\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\n    require(_index \u003c totalSupply());\n    return allTokens[_index];\n  }\n\n  /**\n  * @dev Internal function to set the token URI for a given token\n  * @dev Reverts if the token ID does not exist\n  * @param _tokenId uint256 ID of the token to set its URI\n  * @param _uri string URI to assign\n  */\n  function _setTokenURI(uint256 _tokenId, address _uri) internal {\n    require(exists(_tokenId));\n    tokenURIs[_tokenId] = _uri;\n  }\n\n  /**\n  * @dev Internal function to add a token ID to the list of a given address\n  * @param _to address representing the new owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n  */\n  function addTokenTo(address _to, uint256 _tokenId) internal {\n    super.addTokenTo(_to, _tokenId);\n    uint256 length = ownedTokens[_to].length;\n    ownedTokens[_to].push(_tokenId);\n    ownedTokensIndex[_tokenId] = length;\n  }\n\n  /**\n  * @dev Internal function to remove a token ID from the list of a given address\n  * @param _from address representing the previous owner of the given token ID\n  * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n  */\n  function removeTokenFrom(address _from, uint256 _tokenId) internal {\n    super.removeTokenFrom(_from, _tokenId);\n\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\n\n    ownedTokens[_from][tokenIndex] = lastToken;\n    ownedTokens[_from][lastTokenIndex] = 0;\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\n\n    ownedTokens[_from].length--;\n    ownedTokensIndex[_tokenId] = 0;\n    ownedTokensIndex[lastToken] = tokenIndex;\n  }\n\n  /**\n  * @dev Internal function to mint a new token\n  * @dev Reverts if the given token ID already exists\n  * @param _to address the beneficiary that will own the minted token\n  * @param _tokenId uint256 ID of the token to be minted by the msg.sender\n  */\n  function _mint(address _to, uint256 _tokenId) internal {\n    super._mint(_to, _tokenId);\n\n    allTokensIndex[_tokenId] = allTokens.length;\n    allTokens.push(_tokenId);\n  }\n}\n"},"EternalDb.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./DSAuth.sol\";\n\n/**\n * @title Contract to store arbitrary state data, decoupled from any logic related to it\n *\n * @dev Original implementation: https://blog.colony.io/writing-upgradeable-contracts-in-solidity-6743f0eecc88\n * In addition to original implementation, this contract uses DSAuth for more advanced authentication options\n * It also provides way set/get multiple values in single transaction\n */\n\ncontract EternalDb is DSAuth {\n\n  enum Types {UInt, String, Address, Bytes, Bytes32, Boolean, Int}\n\n  event EternalDbEvent(bytes32[] records, uint[] values, uint timestamp);\n\n  function EternalDb(){\n  }\n\n  ////////////\n  //UInt\n  ////////////\n\n  mapping(bytes32 =\u003e uint) UIntStorage;\n\n  function getUIntValue(bytes32 record) constant returns (uint){\n    return UIntStorage[record];\n  }\n\n  function getUIntValues(bytes32[] records) constant returns (uint[] results){\n    results = new uint[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = UIntStorage[records[i]];\n    }\n  }\n\n  function setUIntValue(bytes32 record, uint value)\n  auth\n  {\n    UIntStorage[record] = value;\n    bytes32[] memory records = new bytes32[](1);\n    records[0] = record;\n    uint[] memory values = new uint[](1);\n    values[0] = value;\n    emit EternalDbEvent(records, values, now);\n  }\n\n  function setUIntValues(bytes32[] records, uint[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      UIntStorage[records[i]] = values[i];\n    }\n    emit EternalDbEvent(records, values, now);\n  }\n\n  function deleteUIntValue(bytes32 record)\n  auth\n  {\n    delete UIntStorage[record];\n  }\n\n  ////////////\n  //Strings\n  ////////////\n\n  mapping(bytes32 =\u003e string) StringStorage;\n\n  function getStringValue(bytes32 record) constant returns (string){\n    return StringStorage[record];\n  }\n\n  function setStringValue(bytes32 record, string value)\n  auth\n  {\n    StringStorage[record] = value;\n  }\n\n  function deleteStringValue(bytes32 record)\n  auth\n  {\n    delete StringStorage[record];\n  }\n\n  ////////////\n  //Address\n  ////////////\n\n  mapping(bytes32 =\u003e address) AddressStorage;\n\n  function getAddressValue(bytes32 record) constant returns (address){\n    return AddressStorage[record];\n  }\n\n  function setAddressValues(bytes32[] records, address[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      AddressStorage[records[i]] = values[i];\n    }\n  }\n\n  function setAddressValue(bytes32 record, address value)\n  auth\n  {\n    AddressStorage[record] = value;\n  }\n\n  function deleteAddressValue(bytes32 record)\n  auth\n  {\n    delete AddressStorage[record];\n  }\n\n  ////////////\n  //Bytes\n  ////////////\n\n  mapping(bytes32 =\u003e bytes) BytesStorage;\n\n  function getBytesValue(bytes32 record) constant returns (bytes){\n    return BytesStorage[record];\n  }\n\n  function setBytesValue(bytes32 record, bytes value)\n  auth\n  {\n    BytesStorage[record] = value;\n  }\n\n  function deleteBytesValue(bytes32 record)\n  auth\n  {\n    delete BytesStorage[record];\n  }\n\n  ////////////\n  //Bytes32\n  ////////////\n\n  mapping(bytes32 =\u003e bytes32) Bytes32Storage;\n\n  function getBytes32Value(bytes32 record) constant returns (bytes32){\n    return Bytes32Storage[record];\n  }\n\n  function getBytes32Values(bytes32[] records) constant returns (bytes32[] results){\n    results = new bytes32[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = Bytes32Storage[records[i]];\n    }\n  }\n\n  function setBytes32Value(bytes32 record, bytes32 value)\n  auth\n  {\n    Bytes32Storage[record] = value;\n  }\n\n  function setBytes32Values(bytes32[] records, bytes32[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      Bytes32Storage[records[i]] = values[i];\n    }\n  }\n\n  function deleteBytes32Value(bytes32 record)\n  auth\n  {\n    delete Bytes32Storage[record];\n  }\n\n  ////////////\n  //Boolean\n  ////////////\n\n  mapping(bytes32 =\u003e bool) BooleanStorage;\n\n  function getBooleanValue(bytes32 record) constant returns (bool){\n    return BooleanStorage[record];\n  }\n\n  function getBooleanValues(bytes32[] records) constant returns (bool[] results){\n    results = new bool[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = BooleanStorage[records[i]];\n    }\n  }\n\n  function setBooleanValue(bytes32 record, bool value)\n  auth\n  {\n    BooleanStorage[record] = value;\n  }\n\n  function setBooleanValues(bytes32[] records, bool[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      BooleanStorage[records[i]] = values[i];\n    }\n  }\n\n  function deleteBooleanValue(bytes32 record)\n  auth\n  {\n    delete BooleanStorage[record];\n  }\n\n  ////////////\n  //Int\n  ////////////\n  mapping(bytes32 =\u003e int) IntStorage;\n\n  function getIntValue(bytes32 record) constant returns (int){\n    return IntStorage[record];\n  }\n\n  function getIntValues(bytes32[] records) constant returns (int[] results){\n    results = new int[](records.length);\n    for (uint i = 0; i \u003c records.length; i++) {\n      results[i] = IntStorage[records[i]];\n    }\n  }\n\n  function setIntValue(bytes32 record, int value)\n  auth\n  {\n    IntStorage[record] = value;\n  }\n\n  function setIntValues(bytes32[] records, int[] values)\n  auth\n  {\n    for (uint i = 0; i \u003c records.length; i++) {\n      IntStorage[records[i]] = values[i];\n    }\n  }\n\n  function deleteIntValue(bytes32 record)\n  auth\n  {\n    delete IntStorage[record];\n  }\n\n}\n"},"MemeToken.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./ERC721Token.sol\";\nimport \"./Registry.sol\";\nimport \"./DSAuth.sol\";\n\n/**\n * @title Token of a Meme. Single ERC721 instance represents all memes/cards\n */\n\ncontract MemeToken is ERC721Token {\n  Registry public registry;\n\n  modifier onlyRegistryEntry() {\n    require(registry.isRegistryEntry(msg.sender),\"MemeToken: onlyRegistryEntry failed\");\n    _;\n  }\n\n  function MemeToken(Registry _registry)\n  ERC721Token(\"MemeToken\", \"MEME\")\n  {\n    registry = _registry;\n  }\n\n  function mint(address _to, uint256 _tokenId)\n  onlyRegistryEntry\n  public\n  {\n    super._mint(_to, _tokenId);\n    tokenURIs[_tokenId] = msg.sender;\n  }\n\n  function safeTransferFromMulti(\n    address _from,\n    address _to,\n    uint256[] _tokenIds,\n    bytes _data\n  ) {\n    for (uint i = 0; i \u003c _tokenIds.length; i++) {\n      safeTransferFrom(_from, _to, _tokenIds[i], _data);\n    }\n  }\n}\n"},"MutableForwarder.sol":{"content":"pragma solidity ^0.4.18;\n\nimport \"./DelegateProxy.sol\";\nimport \"./DSAuth.sol\";\n\n/**\n * @title Forwarder proxy contract with editable target\n *\n * @dev For TCR Registry contracts (Registry.sol, ParamChangeRegistry.sol) we use mutable forwarders instead of using\n * contracts directly. This is for better upgradeability. Since registry contracts fire all events related to registry\n * entries, we want to be able to access whole history of events always on the same address. Which would be address of\n * a MutableForwarder. When a registry contract is replaced with updated one, mutable forwarder just replaces target\n * and all events stay still accessible on the same address.\n */\n\ncontract MutableForwarder is DelegateProxy, DSAuth {\n\n  address public target = 0xBEeFbeefbEefbeEFbeEfbEEfBEeFbeEfBeEfBeef; // checksumed to silence warning\n\n  /**\n   * @dev Replaces targer forwarder contract is pointing to\n   * Only authenticated user can replace target\n\n   * @param _target New target to proxy into\n  */\n  function setTarget(address _target) public auth {\n    target = _target;\n  }\n\n  function() payable {\n    delegatedFwd(target, msg.data);\n  }\n\n}"},"Registry.sol":{"content":"pragma solidity ^0.4.24;\n\nimport \"./DSAuth.sol\";\nimport \"./EternalDb.sol\";\nimport \"./MutableForwarder.sol\"; // Keep it included despite not being used (for compiler)\n\n/**\n * @title Central contract for TCR registry\n *\n * @dev Manages state about deployed registry entries and factories\n * Serves as a central point for firing all registry entry events\n * This contract is not accessed directly, but through MutableForwarder. See MutableForwarder.sol for more comments.\n */\n\ncontract Registry is DSAuth {\n  address private dummyTarget; // Keep it here, because this contract is deployed as MutableForwarder\n\n  bytes32 public constant challengePeriodDurationKey = sha3(\"challengePeriodDuration\");\n  bytes32 public constant commitPeriodDurationKey = sha3(\"commitPeriodDuration\");\n  bytes32 public constant revealPeriodDurationKey = sha3(\"revealPeriodDuration\");\n  bytes32 public constant depositKey = sha3(\"deposit\");\n  bytes32 public constant challengeDispensationKey = sha3(\"challengeDispensation\");\n  bytes32 public constant voteQuorumKey = sha3(\"voteQuorum\");\n  bytes32 public constant maxTotalSupplyKey = sha3(\"maxTotalSupply\");\n  bytes32 public constant maxAuctionDurationKey = sha3(\"maxAuctionDuration\");\n\n  event MemeConstructedEvent(address registryEntry, uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd);\n  event MemeMintedEvent(address registryEntry, uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted);\n\n  event ChallengeCreatedEvent(address registryEntry, uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash);\n  event VoteCommittedEvent(address registryEntry, uint version, address voter, uint amount);\n  event VoteRevealedEvent(address registryEntry, uint version, address voter, uint option);\n  event VoteAmountClaimedEvent(address registryEntry, uint version, address voter);\n  event VoteRewardClaimedEvent(address registryEntry, uint version, address voter, uint amount);\n  event ChallengeRewardClaimedEvent(address registryEntry, uint version, address challenger, uint amount);\n\n  event ParamChangeConstructedEvent(address registryEntry, uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd);\n  event ParamChangeAppliedEvent(address registryEntry, uint version);\n\n  EternalDb public db;\n  bool private wasConstructed;\n\n  /**\n   * @dev Constructor for this contract.\n   * Native constructor is not used, because we use a forwarder pointing to single instance of this contract,\n   * therefore constructor must be called explicitly.\n\n   * @param _db Address of EternalDb related to this registry\n   */\n  function construct(EternalDb _db)\n  external\n  {\n    require(address(_db) != 0x0, \"Registry: Address can\u0027t be 0x0\");\n\n    db = _db;\n    wasConstructed = true;\n    owner = msg.sender;\n  }\n\n  modifier onlyFactory() {\n    require(isFactory(msg.sender), \"Registry: Sender should be factory\");\n    _;\n  }\n\n  modifier onlyRegistryEntry() {\n    require(isRegistryEntry(msg.sender), \"Registry: Sender should registry entry\");\n    _;\n  }\n\n  modifier notEmergency() {\n    require(!isEmergency(),\"Registry: Emergency mode is enable\");\n    _;\n  }\n\n  /**\n   * @dev Sets whether address is factory allowed to add registry entries into registry\n   * Must be callable only by authenticated user\n\n   * @param _factory Address of a factory contract\n   * @param _isFactory Whether the address is allowed factory\n   */\n  function setFactory(address _factory, bool _isFactory)\n  external\n  auth\n  {\n    db.setBooleanValue(sha3(\"isFactory\", _factory), _isFactory);\n  }\n\n  /**\n   * @dev Adds address as valid registry entry into the Registry\n   * Must be callable only by allowed factory contract\n\n   * @param _registryEntry Address of new registry entry\n   */\n  function addRegistryEntry(address _registryEntry)\n  external\n  onlyFactory\n  notEmergency\n  {\n    db.setBooleanValue(sha3(\"isRegistryEntry\", _registryEntry), true);\n  }\n\n  /**\n   * @dev Sets emergency state to pause all trading operations\n   * Must be callable only by authenticated user\n\n   * @param _isEmergency True if emergency is happening\n   */\n  function setEmergency(bool _isEmergency)\n  external\n  auth\n  {\n    db.setBooleanValue(\"isEmergency\", _isEmergency);\n  }\n\n  function fireMemeConstructedEvent(uint version, address creator, bytes metaHash, uint totalSupply, uint deposit, uint challengePeriodEnd)\n  public\n  onlyRegistryEntry\n  {\n    emit MemeConstructedEvent(msg.sender, version, creator, metaHash, totalSupply, deposit, challengePeriodEnd);\n  }\n\n  function fireMemeMintedEvent(uint version, address creator, uint tokenStartId, uint tokenEndId, uint totalMinted)\n  public\n  onlyRegistryEntry\n  {\n    emit MemeMintedEvent(msg.sender, version, creator, tokenStartId, tokenEndId, totalMinted);\n  }\n\n  function fireChallengeCreatedEvent(uint version, address challenger, uint commitPeriodEnd, uint revealPeriodEnd, uint rewardPool, bytes metahash)\n  public\n  onlyRegistryEntry\n  {\n    emit ChallengeCreatedEvent(msg.sender, version,  challenger, commitPeriodEnd, revealPeriodEnd, rewardPool, metahash);\n  }\n\n  function fireVoteCommittedEvent(uint version, address voter, uint amount)\n  public\n  onlyRegistryEntry\n  {\n    emit VoteCommittedEvent(msg.sender, version, voter, amount);\n  }\n\n  function fireVoteRevealedEvent(uint version, address voter, uint option)\n  public\n  onlyRegistryEntry\n  {\n    emit VoteRevealedEvent(msg.sender, version, voter, option);\n  }\n\n  function fireVoteAmountClaimedEvent(uint version, address voter)\n  public\n  onlyRegistryEntry\n  {\n    emit VoteAmountClaimedEvent(msg.sender, version, voter);\n  }\n\n  function fireVoteRewardClaimedEvent(uint version, address voter, uint amount)\n  public\n  onlyRegistryEntry\n  {\n    emit VoteRewardClaimedEvent(msg.sender, version, voter, amount);\n  }\n\n  function fireChallengeRewardClaimedEvent(uint version, address challenger, uint amount)\n  public\n  onlyRegistryEntry\n  {\n    emit ChallengeRewardClaimedEvent(msg.sender, version, challenger, amount);\n  }\n\n  function fireParamChangeConstructedEvent(uint version, address creator, address db, string key, uint value, uint deposit, uint challengePeriodEnd)\n  public\n  onlyRegistryEntry\n  {\n    emit ParamChangeConstructedEvent(msg.sender, version, creator, db, key, value, deposit, challengePeriodEnd);\n  }\n\n  function fireParamChangeAppliedEvent(uint version)\n  public\n  onlyRegistryEntry\n  {\n    emit ParamChangeAppliedEvent(msg.sender, version);\n  }\n\n  /**\n   * @dev Returns whether address is valid registry entry factory\n\n   * @return True if address is factory\n   */\n  function isFactory(address factory) public constant returns (bool) {\n    return db.getBooleanValue(sha3(\"isFactory\", factory));\n  }\n\n  /**\n   * @dev Returns whether address is valid registry entry\n\n   * @return True if address is registry entry\n   */\n  function isRegistryEntry(address registryEntry) public constant returns (bool) {\n    return db.getBooleanValue(sha3(\"isRegistryEntry\", registryEntry));\n  }\n\n  /**\n   * @dev Returns whether emergency stop is happening\n\n   * @return True if emergency is happening\n   */\n  function isEmergency() public constant returns (bool) {\n    return db.getBooleanValue(\"isEmergency\");\n  }\n}\n"},"SafeMath.sol":{"content":"pragma solidity ^0.4.18;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b \u003e 0); // Solidity automatically throws when dividing by 0\n    uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn\u0027t hold\n    return c;\n  }\n\n  /**\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n    assert(b \u003c= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\n    uint256 c = a + b;\n    assert(c \u003e= a);\n    return c;\n  }\n}\n"}}