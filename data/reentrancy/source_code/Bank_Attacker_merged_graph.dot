digraph "" {
	Attacker_constructor_1	[label="Node Type: EXPRESSION 1

EXPRESSION:
bankAddr = _bank

IRs:
bankAddr(address) := _bank(address)"];
	Attacker_constructor_0	[label="Node Type: ENTRY_POINT 0
"];
	Attacker_constructor_0 -> Attacker_constructor_1	[key=0];
	"Attacker_constructor_function.name"	[contract=Attacker,
		label=Attacker_constructor];
	"Attacker_constructor_function.name" -> Attacker_constructor_0	[key=0];
	Attacker_attack_0	[label="Node Type: ENTRY_POINT 0
"];
	Attacker_attack_1	[label="Node Type: EXPRESSION 1

EXPRESSION:
attackCount = 0

IRs:
attackCount(uint256) := 0(uint256)"];
	Attacker_attack_0 -> Attacker_attack_1	[key=0];
	Attacker_attack_2	[label="Node Type: NEW VARIABLE 2

EXPRESSION:
bank = Bank(bankAddr)

IRs:
TMP_3 = CONVERT bankAddr to Bank
bank(Bank) := TMP_3(Bank)"];
	Attacker_attack_1 -> Attacker_attack_2	[key=0];
	Attacker_attack_3	[label="Node Type: EXPRESSION 3

EXPRESSION:
bank.recharge.value(msg.value)()

IRs:
HIGH_LEVEL_CALL, dest:bank(Bank), function:recharge, \
arguments:[] value:msg.value "];
	Attacker_attack_2 -> Attacker_attack_3	[key=0];
	Attacker_attack_4	[label="Node Type: EXPRESSION 4

EXPRESSION:
bank.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:bank(Bank), function:withdraw, arguments:[]  "];
	Attacker_attack_3 -> Attacker_attack_4	[key=0];
	"Attacker_attack_function.name"	[contract=Attacker,
		label=Attacker_attack];
	"Attacker_attack_function.name" -> Attacker_attack_0	[key=0];
	Attacker_fallback_5	[label="Node Type: END_IF 5
"];
	Attacker_fallback_1	[label="Node Type: IF 1

EXPRESSION:
msg.sender == bankAddr && attackCount < 5

IRs:
TMP_7(bool) = msg.sender == bankAddr
TMP_8(bool) = \
attackCount < 5
TMP_9(bool) = TMP_7 && TMP_8
CONDITION TMP_9"];
	Attacker_fallback_1 -> Attacker_fallback_5	[key=0,
		label=False];
	Attacker_fallback_2	[label="Node Type: EXPRESSION 2

EXPRESSION:
attackCount += 1

IRs:
attackCount(uint256) = attackCount + 1"];
	Attacker_fallback_1 -> Attacker_fallback_2	[key=0,
		label=True];
	Attacker_fallback_0	[label="Node Type: ENTRY_POINT 0
"];
	Attacker_fallback_0 -> Attacker_fallback_1	[key=0];
	Attacker_fallback_3	[label="Node Type: NEW VARIABLE 3

EXPRESSION:
bank = Bank(bankAddr)

IRs:
TMP_10 = CONVERT bankAddr to Bank
bank(Bank) := TMP_10(Bank)"];
	Attacker_fallback_2 -> Attacker_fallback_3	[key=0];
	Attacker_fallback_4	[label="Node Type: EXPRESSION 4

EXPRESSION:
bank.withdraw()

IRs:
HIGH_LEVEL_CALL, dest:bank(Bank), function:withdraw, arguments:[]  "];
	Attacker_fallback_3 -> Attacker_fallback_4	[key=0];
	"Attacker_fallback_function.name"	[contract=Attacker,
		label=Attacker_fallback];
	"Attacker_fallback_function.name" -> Attacker_fallback_0	[key=0];
	Attacker_fallback_4 -> Attacker_fallback_5	[key=0];
	Attacker_wallet_1	[label="Node Type: RETURN 1

EXPRESSION:
this.balance

IRs:
REF_10 -> BALANCE this
RETURN REF_10"];
	Attacker_wallet_0	[label="Node Type: ENTRY_POINT 0
"];
	Attacker_wallet_0 -> Attacker_wallet_1	[key=0];
	"Attacker_wallet_function.name"	[contract=Attacker,
		label=Attacker_wallet];
	"Attacker_wallet_function.name" -> Attacker_wallet_0	[key=0];
	Attacker_slitherConstructorVariables_0	[label="Node Type: OTHER_ENTRYPOINT 0

EXPRESSION:
attackCount = 0

IRs:
attackCount(uint256) := 0(uint256)"];
	"Attacker_slitherConstructorVariables_function.name"	[contract=Attacker,
		label=Attacker_slitherConstructorVariables];
	"Attacker_slitherConstructorVariables_function.name" -> Attacker_slitherConstructorVariables_0	[key=0];
}
